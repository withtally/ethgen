// Code generated from parser/Solidity.g4 by ANTLR 4.13.1. DO NOT EDIT.

package parser // Solidity

import (
	"fmt"
	"strconv"
	"sync"

	"github.com/antlr4-go/antlr/v4"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}

type SolidityParser struct {
	*antlr.BaseParser
}

var SolidityParserStaticData struct {
	once                   sync.Once
	serializedATN          []int32
	LiteralNames           []string
	SymbolicNames          []string
	RuleNames              []string
	PredictionContextCache *antlr.PredictionContextCache
	atn                    *antlr.ATN
	decisionToDFA          []*antlr.DFA
}

func solidityParserInit() {
	staticData := &SolidityParserStaticData
	staticData.LiteralNames = []string{
		"", "'pragma'", "';'", "'||'", "'^'", "'~'", "'>='", "'>'", "'<'", "'<='",
		"'='", "'as'", "'import'", "'*'", "'from'", "'{'", "','", "'}'", "'abstract'",
		"'contract'", "'interface'", "'library'", "'is'", "'('", "')'", "'error'",
		"'using'", "'for'", "'struct'", "'modifier'", "'function'", "'returns'",
		"'event'", "'enum'", "'['", "']'", "'address'", "'.'", "'mapping'",
		"'=>'", "'memory'", "'storage'", "'calldata'", "'if'", "'else'", "'try'",
		"'catch'", "'while'", "'unchecked'", "'assembly'", "'do'", "'return'",
		"'throw'", "'emit'", "'revert'", "'var'", "'bool'", "'string'", "'byte'",
		"'++'", "'--'", "'new'", "':'", "'+'", "'-'", "'after'", "'delete'",
		"'!'", "'**'", "'/'", "'%'", "'<<'", "'>>'", "'&'", "'|'", "'=='", "'!='",
		"'&&'", "'?'", "'|='", "'^='", "'&='", "'<<='", "'>>='", "'+='", "'-='",
		"'*='", "'/='", "'%='", "'let'", "':='", "'=:'", "'switch'", "'case'",
		"'default'", "'->'", "'callback'", "'override'", "", "", "", "", "",
		"", "", "", "", "", "", "'anonymous'", "'break'", "'constant'", "'immutable'",
		"'continue'", "'leave'", "'external'", "'indexed'", "'internal'", "'payable'",
		"'private'", "'public'", "'virtual'", "'pure'", "'type'", "'view'",
		"'constructor'", "'fallback'", "'receive'",
	}
	staticData.SymbolicNames = []string{
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "Int", "Uint", "Byte",
		"Fixed", "Ufixed", "BooleanLiteral", "DecimalNumber", "HexNumber", "NumberUnit",
		"HexLiteralFragment", "ReservedKeyword", "AnonymousKeyword", "BreakKeyword",
		"ConstantKeyword", "ImmutableKeyword", "ContinueKeyword", "LeaveKeyword",
		"ExternalKeyword", "IndexedKeyword", "InternalKeyword", "PayableKeyword",
		"PrivateKeyword", "PublicKeyword", "VirtualKeyword", "PureKeyword",
		"TypeKeyword", "ViewKeyword", "ConstructorKeyword", "FallbackKeyword",
		"ReceiveKeyword", "Identifier", "StringLiteralFragment", "VersionLiteral",
		"WS", "COMMENT", "LINE_COMMENT",
	}
	staticData.RuleNames = []string{
		"sourceUnit", "pragmaDirective", "pragmaName", "pragmaValue", "version",
		"versionOperator", "versionConstraint", "importDeclaration", "importDirective",
		"importPath", "contractDefinition", "inheritanceSpecifier", "contractPart",
		"stateVariableDeclaration", "fileLevelConstant", "customErrorDefinition",
		"usingForDeclaration", "structDefinition", "modifierDefinition", "modifierInvocation",
		"functionDefinition", "functionDescriptor", "returnParameters", "modifierList",
		"eventDefinition", "enumValue", "enumDefinition", "parameterList", "parameter",
		"eventParameterList", "eventParameter", "functionTypeParameterList",
		"functionTypeParameter", "variableDeclaration", "typeName", "userDefinedTypeName",
		"mappingKey", "mapping", "functionTypeName", "storageLocation", "stateMutability",
		"block", "statement", "expressionStatement", "ifStatement", "tryStatement",
		"catchClause", "whileStatement", "simpleStatement", "uncheckedStatement",
		"forStatement", "inlineAssemblyStatement", "doWhileStatement", "continueStatement",
		"breakStatement", "returnStatement", "throwStatement", "emitStatement",
		"revertStatement", "variableDeclarationStatement", "variableDeclarationList",
		"identifierList", "elementaryTypeName", "expression", "primaryExpression",
		"expressionList", "nameValueList", "nameValue", "functionCallArguments",
		"functionCall", "assemblyBlock", "assemblyItem", "assemblyExpression",
		"assemblyMember", "assemblyCall", "assemblyLocalDefinition", "assemblyAssignment",
		"assemblyIdentifierOrList", "assemblyIdentifierList", "assemblyStackAssignment",
		"labelDefinition", "assemblySwitch", "assemblyCase", "assemblyFunctionDefinition",
		"assemblyFunctionReturns", "assemblyFor", "assemblyIf", "assemblyLiteral",
		"subAssembly", "tupleExpression", "typeNameExpression", "numberLiteral",
		"identifier", "hexLiteral", "overrideSpecifier", "stringLiteral",
	}
	staticData.PredictionContextCache = antlr.NewPredictionContextCache()
	staticData.serializedATN = []int32{
		4, 1, 133, 1121, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4,
		7, 4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10,
		7, 10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7,
		15, 2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20,
		2, 21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2,
		26, 7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31,
		7, 31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7,
		36, 2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41,
		2, 42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2,
		47, 7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52,
		7, 52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7,
		57, 2, 58, 7, 58, 2, 59, 7, 59, 2, 60, 7, 60, 2, 61, 7, 61, 2, 62, 7, 62,
		2, 63, 7, 63, 2, 64, 7, 64, 2, 65, 7, 65, 2, 66, 7, 66, 2, 67, 7, 67, 2,
		68, 7, 68, 2, 69, 7, 69, 2, 70, 7, 70, 2, 71, 7, 71, 2, 72, 7, 72, 2, 73,
		7, 73, 2, 74, 7, 74, 2, 75, 7, 75, 2, 76, 7, 76, 2, 77, 7, 77, 2, 78, 7,
		78, 2, 79, 7, 79, 2, 80, 7, 80, 2, 81, 7, 81, 2, 82, 7, 82, 2, 83, 7, 83,
		2, 84, 7, 84, 2, 85, 7, 85, 2, 86, 7, 86, 2, 87, 7, 87, 2, 88, 7, 88, 2,
		89, 7, 89, 2, 90, 7, 90, 2, 91, 7, 91, 2, 92, 7, 92, 2, 93, 7, 93, 2, 94,
		7, 94, 2, 95, 7, 95, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 5,
		0, 201, 8, 0, 10, 0, 12, 0, 204, 9, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1,
		1, 1, 1, 1, 2, 1, 2, 1, 3, 1, 3, 3, 3, 217, 8, 3, 1, 4, 1, 4, 3, 4, 221,
		8, 4, 1, 4, 5, 4, 224, 8, 4, 10, 4, 12, 4, 227, 9, 4, 1, 5, 1, 5, 1, 6,
		3, 6, 232, 8, 6, 1, 6, 1, 6, 3, 6, 236, 8, 6, 1, 6, 3, 6, 239, 8, 6, 1,
		7, 1, 7, 1, 7, 3, 7, 244, 8, 7, 1, 8, 1, 8, 1, 8, 1, 8, 3, 8, 250, 8, 8,
		1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 3, 8, 257, 8, 8, 1, 8, 1, 8, 3, 8, 261, 8,
		8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 5, 8, 272, 8,
		8, 10, 8, 12, 8, 275, 9, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 3, 8, 282, 8,
		8, 1, 9, 1, 9, 1, 10, 3, 10, 287, 8, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1,
		10, 1, 10, 5, 10, 295, 8, 10, 10, 10, 12, 10, 298, 9, 10, 3, 10, 300, 8,
		10, 1, 10, 1, 10, 5, 10, 304, 8, 10, 10, 10, 12, 10, 307, 9, 10, 1, 10,
		1, 10, 1, 11, 1, 11, 1, 11, 3, 11, 314, 8, 11, 1, 11, 3, 11, 317, 8, 11,
		1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 3, 12, 327, 8,
		12, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 5, 13, 336, 8, 13,
		10, 13, 12, 13, 339, 9, 13, 1, 13, 1, 13, 1, 13, 3, 13, 344, 8, 13, 1,
		13, 1, 13, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 15, 1, 15,
		1, 15, 1, 15, 1, 15, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 3, 16, 365, 8,
		16, 1, 16, 1, 16, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17,
		5, 17, 377, 8, 17, 10, 17, 12, 17, 380, 9, 17, 3, 17, 382, 8, 17, 1, 17,
		1, 17, 1, 18, 1, 18, 1, 18, 3, 18, 389, 8, 18, 1, 18, 1, 18, 5, 18, 393,
		8, 18, 10, 18, 12, 18, 396, 9, 18, 1, 18, 1, 18, 3, 18, 400, 8, 18, 1,
		19, 1, 19, 1, 19, 3, 19, 405, 8, 19, 1, 19, 3, 19, 408, 8, 19, 1, 20, 1,
		20, 1, 20, 1, 20, 3, 20, 414, 8, 20, 1, 20, 1, 20, 3, 20, 418, 8, 20, 1,
		21, 1, 21, 3, 21, 422, 8, 21, 1, 21, 1, 21, 1, 21, 3, 21, 427, 8, 21, 1,
		22, 1, 22, 1, 22, 1, 23, 1, 23, 1, 23, 1, 23, 1, 23, 1, 23, 1, 23, 1, 23,
		5, 23, 440, 8, 23, 10, 23, 12, 23, 443, 9, 23, 1, 24, 1, 24, 1, 24, 1,
		24, 3, 24, 449, 8, 24, 1, 24, 1, 24, 1, 25, 1, 25, 1, 26, 1, 26, 1, 26,
		1, 26, 3, 26, 459, 8, 26, 1, 26, 1, 26, 5, 26, 463, 8, 26, 10, 26, 12,
		26, 466, 9, 26, 1, 26, 1, 26, 1, 27, 1, 27, 1, 27, 1, 27, 5, 27, 474, 8,
		27, 10, 27, 12, 27, 477, 9, 27, 3, 27, 479, 8, 27, 1, 27, 1, 27, 1, 28,
		1, 28, 3, 28, 485, 8, 28, 1, 28, 3, 28, 488, 8, 28, 1, 29, 1, 29, 1, 29,
		1, 29, 5, 29, 494, 8, 29, 10, 29, 12, 29, 497, 9, 29, 3, 29, 499, 8, 29,
		1, 29, 1, 29, 1, 30, 1, 30, 3, 30, 505, 8, 30, 1, 30, 3, 30, 508, 8, 30,
		1, 31, 1, 31, 1, 31, 1, 31, 5, 31, 514, 8, 31, 10, 31, 12, 31, 517, 9,
		31, 3, 31, 519, 8, 31, 1, 31, 1, 31, 1, 32, 1, 32, 3, 32, 525, 8, 32, 1,
		33, 1, 33, 3, 33, 529, 8, 33, 1, 33, 1, 33, 1, 34, 1, 34, 1, 34, 1, 34,
		1, 34, 1, 34, 1, 34, 3, 34, 540, 8, 34, 1, 34, 1, 34, 1, 34, 3, 34, 545,
		8, 34, 1, 34, 5, 34, 548, 8, 34, 10, 34, 12, 34, 551, 9, 34, 1, 35, 1,
		35, 1, 35, 5, 35, 556, 8, 35, 10, 35, 12, 35, 559, 9, 35, 1, 36, 1, 36,
		3, 36, 563, 8, 36, 1, 37, 1, 37, 1, 37, 1, 37, 1, 37, 1, 37, 1, 37, 1,
		38, 1, 38, 1, 38, 1, 38, 1, 38, 5, 38, 577, 8, 38, 10, 38, 12, 38, 580,
		9, 38, 1, 38, 1, 38, 3, 38, 584, 8, 38, 1, 39, 1, 39, 1, 40, 1, 40, 1,
		41, 1, 41, 5, 41, 592, 8, 41, 10, 41, 12, 41, 595, 9, 41, 1, 41, 1, 41,
		1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 1,
		42, 1, 42, 1, 42, 1, 42, 1, 42, 3, 42, 614, 8, 42, 1, 43, 1, 43, 1, 43,
		1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 3, 44, 626, 8, 44, 1,
		45, 1, 45, 1, 45, 3, 45, 631, 8, 45, 1, 45, 1, 45, 4, 45, 635, 8, 45, 11,
		45, 12, 45, 636, 1, 46, 1, 46, 3, 46, 641, 8, 46, 1, 46, 3, 46, 644, 8,
		46, 1, 46, 1, 46, 1, 47, 1, 47, 1, 47, 1, 47, 1, 47, 1, 47, 1, 48, 1, 48,
		3, 48, 656, 8, 48, 1, 49, 1, 49, 1, 49, 1, 50, 1, 50, 1, 50, 1, 50, 3,
		50, 665, 8, 50, 1, 50, 1, 50, 3, 50, 669, 8, 50, 1, 50, 3, 50, 672, 8,
		50, 1, 50, 1, 50, 1, 50, 1, 51, 1, 51, 3, 51, 679, 8, 51, 1, 51, 1, 51,
		1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 53, 1, 53, 1,
		53, 1, 54, 1, 54, 1, 54, 1, 55, 1, 55, 3, 55, 699, 8, 55, 1, 55, 1, 55,
		1, 56, 1, 56, 1, 56, 1, 57, 1, 57, 1, 57, 1, 57, 1, 58, 1, 58, 1, 58, 1,
		58, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 3, 59, 721, 8, 59,
		1, 59, 1, 59, 3, 59, 725, 8, 59, 1, 59, 1, 59, 1, 60, 3, 60, 730, 8, 60,
		1, 60, 1, 60, 3, 60, 734, 8, 60, 5, 60, 736, 8, 60, 10, 60, 12, 60, 739,
		9, 60, 1, 61, 1, 61, 3, 61, 743, 8, 61, 1, 61, 5, 61, 746, 8, 61, 10, 61,
		12, 61, 749, 9, 61, 1, 61, 3, 61, 752, 8, 61, 1, 61, 1, 61, 1, 62, 1, 62,
		1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1,
		63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 3, 63, 776, 8, 63,
		1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1,
		63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63,
		1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1,
		63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63,
		1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 3,
		63, 830, 8, 63, 1, 63, 1, 63, 3, 63, 834, 8, 63, 1, 63, 1, 63, 1, 63, 1,
		63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63,
		5, 63, 850, 8, 63, 10, 63, 12, 63, 853, 9, 63, 1, 64, 1, 64, 1, 64, 1,
		64, 1, 64, 1, 64, 1, 64, 3, 64, 862, 8, 64, 1, 64, 1, 64, 1, 64, 1, 64,
		1, 64, 1, 64, 3, 64, 870, 8, 64, 3, 64, 872, 8, 64, 1, 65, 1, 65, 1, 65,
		5, 65, 877, 8, 65, 10, 65, 12, 65, 880, 9, 65, 1, 66, 1, 66, 1, 66, 5,
		66, 885, 8, 66, 10, 66, 12, 66, 888, 9, 66, 1, 66, 3, 66, 891, 8, 66, 1,
		67, 1, 67, 1, 67, 1, 67, 1, 68, 1, 68, 3, 68, 899, 8, 68, 1, 68, 1, 68,
		3, 68, 903, 8, 68, 3, 68, 905, 8, 68, 1, 69, 1, 69, 1, 69, 1, 69, 1, 69,
		1, 70, 1, 70, 5, 70, 914, 8, 70, 10, 70, 12, 70, 917, 9, 70, 1, 70, 1,
		70, 1, 71, 1, 71, 1, 71, 1, 71, 1, 71, 1, 71, 1, 71, 1, 71, 1, 71, 1, 71,
		1, 71, 1, 71, 1, 71, 1, 71, 1, 71, 1, 71, 1, 71, 1, 71, 3, 71, 939, 8,
		71, 1, 72, 1, 72, 1, 72, 3, 72, 944, 8, 72, 1, 73, 1, 73, 1, 73, 1, 73,
		1, 74, 1, 74, 1, 74, 1, 74, 3, 74, 954, 8, 74, 1, 74, 1, 74, 3, 74, 958,
		8, 74, 1, 74, 1, 74, 5, 74, 962, 8, 74, 10, 74, 12, 74, 965, 9, 74, 1,
		74, 3, 74, 968, 8, 74, 1, 75, 1, 75, 1, 75, 1, 75, 3, 75, 974, 8, 75, 1,
		76, 1, 76, 1, 76, 1, 76, 1, 77, 1, 77, 1, 77, 1, 77, 1, 77, 1, 77, 3, 77,
		986, 8, 77, 1, 78, 1, 78, 1, 78, 5, 78, 991, 8, 78, 10, 78, 12, 78, 994,
		9, 78, 1, 79, 1, 79, 1, 79, 1, 80, 1, 80, 1, 80, 1, 81, 1, 81, 1, 81, 5,
		81, 1005, 8, 81, 10, 81, 12, 81, 1008, 9, 81, 1, 82, 1, 82, 1, 82, 1, 82,
		1, 82, 1, 82, 3, 82, 1016, 8, 82, 1, 83, 1, 83, 1, 83, 1, 83, 3, 83, 1022,
		8, 83, 1, 83, 1, 83, 3, 83, 1026, 8, 83, 1, 83, 1, 83, 1, 84, 1, 84, 1,
		84, 1, 85, 1, 85, 1, 85, 3, 85, 1036, 8, 85, 1, 85, 1, 85, 1, 85, 3, 85,
		1041, 8, 85, 1, 85, 1, 85, 1, 86, 1, 86, 1, 86, 1, 86, 1, 87, 1, 87, 1,
		87, 1, 87, 3, 87, 1053, 8, 87, 1, 88, 1, 88, 1, 88, 1, 88, 1, 89, 1, 89,
		3, 89, 1061, 8, 89, 1, 89, 1, 89, 3, 89, 1065, 8, 89, 5, 89, 1067, 8, 89,
		10, 89, 12, 89, 1070, 9, 89, 1, 89, 1, 89, 1, 89, 1, 89, 1, 89, 5, 89,
		1077, 8, 89, 10, 89, 12, 89, 1080, 9, 89, 3, 89, 1082, 8, 89, 1, 89, 3,
		89, 1085, 8, 89, 1, 90, 1, 90, 3, 90, 1089, 8, 90, 1, 91, 1, 91, 3, 91,
		1093, 8, 91, 1, 92, 1, 92, 1, 93, 4, 93, 1098, 8, 93, 11, 93, 12, 93, 1099,
		1, 94, 1, 94, 1, 94, 1, 94, 1, 94, 5, 94, 1107, 8, 94, 10, 94, 12, 94,
		1110, 9, 94, 1, 94, 1, 94, 3, 94, 1114, 8, 94, 1, 95, 4, 95, 1117, 8, 95,
		11, 95, 12, 95, 1118, 1, 95, 0, 2, 68, 126, 96, 0, 2, 4, 6, 8, 10, 12,
		14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48,
		50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84,
		86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116,
		118, 120, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 142, 144, 146,
		148, 150, 152, 154, 156, 158, 160, 162, 164, 166, 168, 170, 172, 174, 176,
		178, 180, 182, 184, 186, 188, 190, 0, 15, 1, 0, 4, 10, 1, 0, 19, 21, 1,
		0, 40, 42, 4, 0, 111, 111, 118, 118, 122, 122, 124, 124, 3, 0, 36, 36,
		55, 58, 98, 102, 1, 0, 59, 60, 1, 0, 63, 64, 1, 0, 65, 66, 2, 0, 13, 13,
		69, 70, 1, 0, 71, 72, 1, 0, 6, 9, 1, 0, 75, 76, 2, 0, 10, 10, 79, 88, 1,
		0, 104, 105, 9, 0, 14, 14, 25, 25, 42, 42, 54, 54, 96, 96, 114, 114, 118,
		118, 125, 125, 127, 128, 1245, 0, 202, 1, 0, 0, 0, 2, 207, 1, 0, 0, 0,
		4, 212, 1, 0, 0, 0, 6, 216, 1, 0, 0, 0, 8, 218, 1, 0, 0, 0, 10, 228, 1,
		0, 0, 0, 12, 238, 1, 0, 0, 0, 14, 240, 1, 0, 0, 0, 16, 281, 1, 0, 0, 0,
		18, 283, 1, 0, 0, 0, 20, 286, 1, 0, 0, 0, 22, 310, 1, 0, 0, 0, 24, 326,
		1, 0, 0, 0, 26, 328, 1, 0, 0, 0, 28, 347, 1, 0, 0, 0, 30, 354, 1, 0, 0,
		0, 32, 359, 1, 0, 0, 0, 34, 368, 1, 0, 0, 0, 36, 385, 1, 0, 0, 0, 38, 401,
		1, 0, 0, 0, 40, 409, 1, 0, 0, 0, 42, 426, 1, 0, 0, 0, 44, 428, 1, 0, 0,
		0, 46, 441, 1, 0, 0, 0, 48, 444, 1, 0, 0, 0, 50, 452, 1, 0, 0, 0, 52, 454,
		1, 0, 0, 0, 54, 469, 1, 0, 0, 0, 56, 482, 1, 0, 0, 0, 58, 489, 1, 0, 0,
		0, 60, 502, 1, 0, 0, 0, 62, 509, 1, 0, 0, 0, 64, 522, 1, 0, 0, 0, 66, 526,
		1, 0, 0, 0, 68, 539, 1, 0, 0, 0, 70, 552, 1, 0, 0, 0, 72, 562, 1, 0, 0,
		0, 74, 564, 1, 0, 0, 0, 76, 571, 1, 0, 0, 0, 78, 585, 1, 0, 0, 0, 80, 587,
		1, 0, 0, 0, 82, 589, 1, 0, 0, 0, 84, 613, 1, 0, 0, 0, 86, 615, 1, 0, 0,
		0, 88, 618, 1, 0, 0, 0, 90, 627, 1, 0, 0, 0, 92, 638, 1, 0, 0, 0, 94, 647,
		1, 0, 0, 0, 96, 655, 1, 0, 0, 0, 98, 657, 1, 0, 0, 0, 100, 660, 1, 0, 0,
		0, 102, 676, 1, 0, 0, 0, 104, 682, 1, 0, 0, 0, 106, 690, 1, 0, 0, 0, 108,
		693, 1, 0, 0, 0, 110, 696, 1, 0, 0, 0, 112, 702, 1, 0, 0, 0, 114, 705,
		1, 0, 0, 0, 116, 709, 1, 0, 0, 0, 118, 720, 1, 0, 0, 0, 120, 729, 1, 0,
		0, 0, 122, 740, 1, 0, 0, 0, 124, 755, 1, 0, 0, 0, 126, 775, 1, 0, 0, 0,
		128, 871, 1, 0, 0, 0, 130, 873, 1, 0, 0, 0, 132, 881, 1, 0, 0, 0, 134,
		892, 1, 0, 0, 0, 136, 904, 1, 0, 0, 0, 138, 906, 1, 0, 0, 0, 140, 911,
		1, 0, 0, 0, 142, 938, 1, 0, 0, 0, 144, 943, 1, 0, 0, 0, 146, 945, 1, 0,
		0, 0, 148, 953, 1, 0, 0, 0, 150, 969, 1, 0, 0, 0, 152, 975, 1, 0, 0, 0,
		154, 985, 1, 0, 0, 0, 156, 987, 1, 0, 0, 0, 158, 995, 1, 0, 0, 0, 160,
		998, 1, 0, 0, 0, 162, 1001, 1, 0, 0, 0, 164, 1015, 1, 0, 0, 0, 166, 1017,
		1, 0, 0, 0, 168, 1029, 1, 0, 0, 0, 170, 1032, 1, 0, 0, 0, 172, 1044, 1,
		0, 0, 0, 174, 1052, 1, 0, 0, 0, 176, 1054, 1, 0, 0, 0, 178, 1084, 1, 0,
		0, 0, 180, 1088, 1, 0, 0, 0, 182, 1090, 1, 0, 0, 0, 184, 1094, 1, 0, 0,
		0, 186, 1097, 1, 0, 0, 0, 188, 1101, 1, 0, 0, 0, 190, 1116, 1, 0, 0, 0,
		192, 201, 3, 2, 1, 0, 193, 201, 3, 16, 8, 0, 194, 201, 3, 20, 10, 0, 195,
		201, 3, 52, 26, 0, 196, 201, 3, 34, 17, 0, 197, 201, 3, 40, 20, 0, 198,
		201, 3, 28, 14, 0, 199, 201, 3, 30, 15, 0, 200, 192, 1, 0, 0, 0, 200, 193,
		1, 0, 0, 0, 200, 194, 1, 0, 0, 0, 200, 195, 1, 0, 0, 0, 200, 196, 1, 0,
		0, 0, 200, 197, 1, 0, 0, 0, 200, 198, 1, 0, 0, 0, 200, 199, 1, 0, 0, 0,
		201, 204, 1, 0, 0, 0, 202, 200, 1, 0, 0, 0, 202, 203, 1, 0, 0, 0, 203,
		205, 1, 0, 0, 0, 204, 202, 1, 0, 0, 0, 205, 206, 5, 0, 0, 1, 206, 1, 1,
		0, 0, 0, 207, 208, 5, 1, 0, 0, 208, 209, 3, 4, 2, 0, 209, 210, 3, 6, 3,
		0, 210, 211, 5, 2, 0, 0, 211, 3, 1, 0, 0, 0, 212, 213, 3, 184, 92, 0, 213,
		5, 1, 0, 0, 0, 214, 217, 3, 8, 4, 0, 215, 217, 3, 126, 63, 0, 216, 214,
		1, 0, 0, 0, 216, 215, 1, 0, 0, 0, 217, 7, 1, 0, 0, 0, 218, 225, 3, 12,
		6, 0, 219, 221, 5, 3, 0, 0, 220, 219, 1, 0, 0, 0, 220, 221, 1, 0, 0, 0,
		221, 222, 1, 0, 0, 0, 222, 224, 3, 12, 6, 0, 223, 220, 1, 0, 0, 0, 224,
		227, 1, 0, 0, 0, 225, 223, 1, 0, 0, 0, 225, 226, 1, 0, 0, 0, 226, 9, 1,
		0, 0, 0, 227, 225, 1, 0, 0, 0, 228, 229, 7, 0, 0, 0, 229, 11, 1, 0, 0,
		0, 230, 232, 3, 10, 5, 0, 231, 230, 1, 0, 0, 0, 231, 232, 1, 0, 0, 0, 232,
		233, 1, 0, 0, 0, 233, 239, 5, 130, 0, 0, 234, 236, 3, 10, 5, 0, 235, 234,
		1, 0, 0, 0, 235, 236, 1, 0, 0, 0, 236, 237, 1, 0, 0, 0, 237, 239, 5, 104,
		0, 0, 238, 231, 1, 0, 0, 0, 238, 235, 1, 0, 0, 0, 239, 13, 1, 0, 0, 0,
		240, 243, 3, 184, 92, 0, 241, 242, 5, 11, 0, 0, 242, 244, 3, 184, 92, 0,
		243, 241, 1, 0, 0, 0, 243, 244, 1, 0, 0, 0, 244, 15, 1, 0, 0, 0, 245, 246,
		5, 12, 0, 0, 246, 249, 3, 18, 9, 0, 247, 248, 5, 11, 0, 0, 248, 250, 3,
		184, 92, 0, 249, 247, 1, 0, 0, 0, 249, 250, 1, 0, 0, 0, 250, 251, 1, 0,
		0, 0, 251, 252, 5, 2, 0, 0, 252, 282, 1, 0, 0, 0, 253, 256, 5, 12, 0, 0,
		254, 257, 5, 13, 0, 0, 255, 257, 3, 184, 92, 0, 256, 254, 1, 0, 0, 0, 256,
		255, 1, 0, 0, 0, 257, 260, 1, 0, 0, 0, 258, 259, 5, 11, 0, 0, 259, 261,
		3, 184, 92, 0, 260, 258, 1, 0, 0, 0, 260, 261, 1, 0, 0, 0, 261, 262, 1,
		0, 0, 0, 262, 263, 5, 14, 0, 0, 263, 264, 3, 18, 9, 0, 264, 265, 5, 2,
		0, 0, 265, 282, 1, 0, 0, 0, 266, 267, 5, 12, 0, 0, 267, 268, 5, 15, 0,
		0, 268, 273, 3, 14, 7, 0, 269, 270, 5, 16, 0, 0, 270, 272, 3, 14, 7, 0,
		271, 269, 1, 0, 0, 0, 272, 275, 1, 0, 0, 0, 273, 271, 1, 0, 0, 0, 273,
		274, 1, 0, 0, 0, 274, 276, 1, 0, 0, 0, 275, 273, 1, 0, 0, 0, 276, 277,
		5, 17, 0, 0, 277, 278, 5, 14, 0, 0, 278, 279, 3, 18, 9, 0, 279, 280, 5,
		2, 0, 0, 280, 282, 1, 0, 0, 0, 281, 245, 1, 0, 0, 0, 281, 253, 1, 0, 0,
		0, 281, 266, 1, 0, 0, 0, 282, 17, 1, 0, 0, 0, 283, 284, 5, 129, 0, 0, 284,
		19, 1, 0, 0, 0, 285, 287, 5, 18, 0, 0, 286, 285, 1, 0, 0, 0, 286, 287,
		1, 0, 0, 0, 287, 288, 1, 0, 0, 0, 288, 289, 7, 1, 0, 0, 289, 299, 3, 184,
		92, 0, 290, 291, 5, 22, 0, 0, 291, 296, 3, 22, 11, 0, 292, 293, 5, 16,
		0, 0, 293, 295, 3, 22, 11, 0, 294, 292, 1, 0, 0, 0, 295, 298, 1, 0, 0,
		0, 296, 294, 1, 0, 0, 0, 296, 297, 1, 0, 0, 0, 297, 300, 1, 0, 0, 0, 298,
		296, 1, 0, 0, 0, 299, 290, 1, 0, 0, 0, 299, 300, 1, 0, 0, 0, 300, 301,
		1, 0, 0, 0, 301, 305, 5, 15, 0, 0, 302, 304, 3, 24, 12, 0, 303, 302, 1,
		0, 0, 0, 304, 307, 1, 0, 0, 0, 305, 303, 1, 0, 0, 0, 305, 306, 1, 0, 0,
		0, 306, 308, 1, 0, 0, 0, 307, 305, 1, 0, 0, 0, 308, 309, 5, 17, 0, 0, 309,
		21, 1, 0, 0, 0, 310, 316, 3, 70, 35, 0, 311, 313, 5, 23, 0, 0, 312, 314,
		3, 130, 65, 0, 313, 312, 1, 0, 0, 0, 313, 314, 1, 0, 0, 0, 314, 315, 1,
		0, 0, 0, 315, 317, 5, 24, 0, 0, 316, 311, 1, 0, 0, 0, 316, 317, 1, 0, 0,
		0, 317, 23, 1, 0, 0, 0, 318, 327, 3, 26, 13, 0, 319, 327, 3, 32, 16, 0,
		320, 327, 3, 34, 17, 0, 321, 327, 3, 36, 18, 0, 322, 327, 3, 40, 20, 0,
		323, 327, 3, 48, 24, 0, 324, 327, 3, 52, 26, 0, 325, 327, 3, 30, 15, 0,
		326, 318, 1, 0, 0, 0, 326, 319, 1, 0, 0, 0, 326, 320, 1, 0, 0, 0, 326,
		321, 1, 0, 0, 0, 326, 322, 1, 0, 0, 0, 326, 323, 1, 0, 0, 0, 326, 324,
		1, 0, 0, 0, 326, 325, 1, 0, 0, 0, 327, 25, 1, 0, 0, 0, 328, 337, 3, 68,
		34, 0, 329, 336, 5, 120, 0, 0, 330, 336, 5, 117, 0, 0, 331, 336, 5, 119,
		0, 0, 332, 336, 5, 111, 0, 0, 333, 336, 5, 112, 0, 0, 334, 336, 3, 188,
		94, 0, 335, 329, 1, 0, 0, 0, 335, 330, 1, 0, 0, 0, 335, 331, 1, 0, 0, 0,
		335, 332, 1, 0, 0, 0, 335, 333, 1, 0, 0, 0, 335, 334, 1, 0, 0, 0, 336,
		339, 1, 0, 0, 0, 337, 335, 1, 0, 0, 0, 337, 338, 1, 0, 0, 0, 338, 340,
		1, 0, 0, 0, 339, 337, 1, 0, 0, 0, 340, 343, 3, 184, 92, 0, 341, 342, 5,
		10, 0, 0, 342, 344, 3, 126, 63, 0, 343, 341, 1, 0, 0, 0, 343, 344, 1, 0,
		0, 0, 344, 345, 1, 0, 0, 0, 345, 346, 5, 2, 0, 0, 346, 27, 1, 0, 0, 0,
		347, 348, 3, 68, 34, 0, 348, 349, 5, 111, 0, 0, 349, 350, 3, 184, 92, 0,
		350, 351, 5, 10, 0, 0, 351, 352, 3, 126, 63, 0, 352, 353, 5, 2, 0, 0, 353,
		29, 1, 0, 0, 0, 354, 355, 5, 25, 0, 0, 355, 356, 3, 184, 92, 0, 356, 357,
		3, 54, 27, 0, 357, 358, 5, 2, 0, 0, 358, 31, 1, 0, 0, 0, 359, 360, 5, 26,
		0, 0, 360, 361, 3, 184, 92, 0, 361, 364, 5, 27, 0, 0, 362, 365, 5, 13,
		0, 0, 363, 365, 3, 68, 34, 0, 364, 362, 1, 0, 0, 0, 364, 363, 1, 0, 0,
		0, 365, 366, 1, 0, 0, 0, 366, 367, 5, 2, 0, 0, 367, 33, 1, 0, 0, 0, 368,
		369, 5, 28, 0, 0, 369, 370, 3, 184, 92, 0, 370, 381, 5, 15, 0, 0, 371,
		372, 3, 66, 33, 0, 372, 378, 5, 2, 0, 0, 373, 374, 3, 66, 33, 0, 374, 375,
		5, 2, 0, 0, 375, 377, 1, 0, 0, 0, 376, 373, 1, 0, 0, 0, 377, 380, 1, 0,
		0, 0, 378, 376, 1, 0, 0, 0, 378, 379, 1, 0, 0, 0, 379, 382, 1, 0, 0, 0,
		380, 378, 1, 0, 0, 0, 381, 371, 1, 0, 0, 0, 381, 382, 1, 0, 0, 0, 382,
		383, 1, 0, 0, 0, 383, 384, 5, 17, 0, 0, 384, 35, 1, 0, 0, 0, 385, 386,
		5, 29, 0, 0, 386, 388, 3, 184, 92, 0, 387, 389, 3, 54, 27, 0, 388, 387,
		1, 0, 0, 0, 388, 389, 1, 0, 0, 0, 389, 394, 1, 0, 0, 0, 390, 393, 5, 121,
		0, 0, 391, 393, 3, 188, 94, 0, 392, 390, 1, 0, 0, 0, 392, 391, 1, 0, 0,
		0, 393, 396, 1, 0, 0, 0, 394, 392, 1, 0, 0, 0, 394, 395, 1, 0, 0, 0, 395,
		399, 1, 0, 0, 0, 396, 394, 1, 0, 0, 0, 397, 400, 5, 2, 0, 0, 398, 400,
		3, 82, 41, 0, 399, 397, 1, 0, 0, 0, 399, 398, 1, 0, 0, 0, 400, 37, 1, 0,
		0, 0, 401, 407, 3, 184, 92, 0, 402, 404, 5, 23, 0, 0, 403, 405, 3, 130,
		65, 0, 404, 403, 1, 0, 0, 0, 404, 405, 1, 0, 0, 0, 405, 406, 1, 0, 0, 0,
		406, 408, 5, 24, 0, 0, 407, 402, 1, 0, 0, 0, 407, 408, 1, 0, 0, 0, 408,
		39, 1, 0, 0, 0, 409, 410, 3, 42, 21, 0, 410, 411, 3, 54, 27, 0, 411, 413,
		3, 46, 23, 0, 412, 414, 3, 44, 22, 0, 413, 412, 1, 0, 0, 0, 413, 414, 1,
		0, 0, 0, 414, 417, 1, 0, 0, 0, 415, 418, 5, 2, 0, 0, 416, 418, 3, 82, 41,
		0, 417, 415, 1, 0, 0, 0, 417, 416, 1, 0, 0, 0, 418, 41, 1, 0, 0, 0, 419,
		421, 5, 30, 0, 0, 420, 422, 3, 184, 92, 0, 421, 420, 1, 0, 0, 0, 421, 422,
		1, 0, 0, 0, 422, 427, 1, 0, 0, 0, 423, 427, 5, 125, 0, 0, 424, 427, 5,
		126, 0, 0, 425, 427, 5, 127, 0, 0, 426, 419, 1, 0, 0, 0, 426, 423, 1, 0,
		0, 0, 426, 424, 1, 0, 0, 0, 426, 425, 1, 0, 0, 0, 427, 43, 1, 0, 0, 0,
		428, 429, 5, 31, 0, 0, 429, 430, 3, 54, 27, 0, 430, 45, 1, 0, 0, 0, 431,
		440, 5, 115, 0, 0, 432, 440, 5, 120, 0, 0, 433, 440, 5, 117, 0, 0, 434,
		440, 5, 119, 0, 0, 435, 440, 5, 121, 0, 0, 436, 440, 3, 80, 40, 0, 437,
		440, 3, 38, 19, 0, 438, 440, 3, 188, 94, 0, 439, 431, 1, 0, 0, 0, 439,
		432, 1, 0, 0, 0, 439, 433, 1, 0, 0, 0, 439, 434, 1, 0, 0, 0, 439, 435,
		1, 0, 0, 0, 439, 436, 1, 0, 0, 0, 439, 437, 1, 0, 0, 0, 439, 438, 1, 0,
		0, 0, 440, 443, 1, 0, 0, 0, 441, 439, 1, 0, 0, 0, 441, 442, 1, 0, 0, 0,
		442, 47, 1, 0, 0, 0, 443, 441, 1, 0, 0, 0, 444, 445, 5, 32, 0, 0, 445,
		446, 3, 184, 92, 0, 446, 448, 3, 58, 29, 0, 447, 449, 5, 109, 0, 0, 448,
		447, 1, 0, 0, 0, 448, 449, 1, 0, 0, 0, 449, 450, 1, 0, 0, 0, 450, 451,
		5, 2, 0, 0, 451, 49, 1, 0, 0, 0, 452, 453, 3, 184, 92, 0, 453, 51, 1, 0,
		0, 0, 454, 455, 5, 33, 0, 0, 455, 456, 3, 184, 92, 0, 456, 458, 5, 15,
		0, 0, 457, 459, 3, 50, 25, 0, 458, 457, 1, 0, 0, 0, 458, 459, 1, 0, 0,
		0, 459, 464, 1, 0, 0, 0, 460, 461, 5, 16, 0, 0, 461, 463, 3, 50, 25, 0,
		462, 460, 1, 0, 0, 0, 463, 466, 1, 0, 0, 0, 464, 462, 1, 0, 0, 0, 464,
		465, 1, 0, 0, 0, 465, 467, 1, 0, 0, 0, 466, 464, 1, 0, 0, 0, 467, 468,
		5, 17, 0, 0, 468, 53, 1, 0, 0, 0, 469, 478, 5, 23, 0, 0, 470, 475, 3, 56,
		28, 0, 471, 472, 5, 16, 0, 0, 472, 474, 3, 56, 28, 0, 473, 471, 1, 0, 0,
		0, 474, 477, 1, 0, 0, 0, 475, 473, 1, 0, 0, 0, 475, 476, 1, 0, 0, 0, 476,
		479, 1, 0, 0, 0, 477, 475, 1, 0, 0, 0, 478, 470, 1, 0, 0, 0, 478, 479,
		1, 0, 0, 0, 479, 480, 1, 0, 0, 0, 480, 481, 5, 24, 0, 0, 481, 55, 1, 0,
		0, 0, 482, 484, 3, 68, 34, 0, 483, 485, 3, 78, 39, 0, 484, 483, 1, 0, 0,
		0, 484, 485, 1, 0, 0, 0, 485, 487, 1, 0, 0, 0, 486, 488, 3, 184, 92, 0,
		487, 486, 1, 0, 0, 0, 487, 488, 1, 0, 0, 0, 488, 57, 1, 0, 0, 0, 489, 498,
		5, 23, 0, 0, 490, 495, 3, 60, 30, 0, 491, 492, 5, 16, 0, 0, 492, 494, 3,
		60, 30, 0, 493, 491, 1, 0, 0, 0, 494, 497, 1, 0, 0, 0, 495, 493, 1, 0,
		0, 0, 495, 496, 1, 0, 0, 0, 496, 499, 1, 0, 0, 0, 497, 495, 1, 0, 0, 0,
		498, 490, 1, 0, 0, 0, 498, 499, 1, 0, 0, 0, 499, 500, 1, 0, 0, 0, 500,
		501, 5, 24, 0, 0, 501, 59, 1, 0, 0, 0, 502, 504, 3, 68, 34, 0, 503, 505,
		5, 116, 0, 0, 504, 503, 1, 0, 0, 0, 504, 505, 1, 0, 0, 0, 505, 507, 1,
		0, 0, 0, 506, 508, 3, 184, 92, 0, 507, 506, 1, 0, 0, 0, 507, 508, 1, 0,
		0, 0, 508, 61, 1, 0, 0, 0, 509, 518, 5, 23, 0, 0, 510, 515, 3, 64, 32,
		0, 511, 512, 5, 16, 0, 0, 512, 514, 3, 64, 32, 0, 513, 511, 1, 0, 0, 0,
		514, 517, 1, 0, 0, 0, 515, 513, 1, 0, 0, 0, 515, 516, 1, 0, 0, 0, 516,
		519, 1, 0, 0, 0, 517, 515, 1, 0, 0, 0, 518, 510, 1, 0, 0, 0, 518, 519,
		1, 0, 0, 0, 519, 520, 1, 0, 0, 0, 520, 521, 5, 24, 0, 0, 521, 63, 1, 0,
		0, 0, 522, 524, 3, 68, 34, 0, 523, 525, 3, 78, 39, 0, 524, 523, 1, 0, 0,
		0, 524, 525, 1, 0, 0, 0, 525, 65, 1, 0, 0, 0, 526, 528, 3, 68, 34, 0, 527,
		529, 3, 78, 39, 0, 528, 527, 1, 0, 0, 0, 528, 529, 1, 0, 0, 0, 529, 530,
		1, 0, 0, 0, 530, 531, 3, 184, 92, 0, 531, 67, 1, 0, 0, 0, 532, 533, 6,
		34, -1, 0, 533, 540, 3, 124, 62, 0, 534, 540, 3, 70, 35, 0, 535, 540, 3,
		74, 37, 0, 536, 540, 3, 76, 38, 0, 537, 538, 5, 36, 0, 0, 538, 540, 5,
		118, 0, 0, 539, 532, 1, 0, 0, 0, 539, 534, 1, 0, 0, 0, 539, 535, 1, 0,
		0, 0, 539, 536, 1, 0, 0, 0, 539, 537, 1, 0, 0, 0, 540, 549, 1, 0, 0, 0,
		541, 542, 10, 3, 0, 0, 542, 544, 5, 34, 0, 0, 543, 545, 3, 126, 63, 0,
		544, 543, 1, 0, 0, 0, 544, 545, 1, 0, 0, 0, 545, 546, 1, 0, 0, 0, 546,
		548, 5, 35, 0, 0, 547, 541, 1, 0, 0, 0, 548, 551, 1, 0, 0, 0, 549, 547,
		1, 0, 0, 0, 549, 550, 1, 0, 0, 0, 550, 69, 1, 0, 0, 0, 551, 549, 1, 0,
		0, 0, 552, 557, 3, 184, 92, 0, 553, 554, 5, 37, 0, 0, 554, 556, 3, 184,
		92, 0, 555, 553, 1, 0, 0, 0, 556, 559, 1, 0, 0, 0, 557, 555, 1, 0, 0, 0,
		557, 558, 1, 0, 0, 0, 558, 71, 1, 0, 0, 0, 559, 557, 1, 0, 0, 0, 560, 563,
		3, 124, 62, 0, 561, 563, 3, 70, 35, 0, 562, 560, 1, 0, 0, 0, 562, 561,
		1, 0, 0, 0, 563, 73, 1, 0, 0, 0, 564, 565, 5, 38, 0, 0, 565, 566, 5, 23,
		0, 0, 566, 567, 3, 72, 36, 0, 567, 568, 5, 39, 0, 0, 568, 569, 3, 68, 34,
		0, 569, 570, 5, 24, 0, 0, 570, 75, 1, 0, 0, 0, 571, 572, 5, 30, 0, 0, 572,
		578, 3, 62, 31, 0, 573, 577, 5, 117, 0, 0, 574, 577, 5, 115, 0, 0, 575,
		577, 3, 80, 40, 0, 576, 573, 1, 0, 0, 0, 576, 574, 1, 0, 0, 0, 576, 575,
		1, 0, 0, 0, 577, 580, 1, 0, 0, 0, 578, 576, 1, 0, 0, 0, 578, 579, 1, 0,
		0, 0, 579, 583, 1, 0, 0, 0, 580, 578, 1, 0, 0, 0, 581, 582, 5, 31, 0, 0,
		582, 584, 3, 62, 31, 0, 583, 581, 1, 0, 0, 0, 583, 584, 1, 0, 0, 0, 584,
		77, 1, 0, 0, 0, 585, 586, 7, 2, 0, 0, 586, 79, 1, 0, 0, 0, 587, 588, 7,
		3, 0, 0, 588, 81, 1, 0, 0, 0, 589, 593, 5, 15, 0, 0, 590, 592, 3, 84, 42,
		0, 591, 590, 1, 0, 0, 0, 592, 595, 1, 0, 0, 0, 593, 591, 1, 0, 0, 0, 593,
		594, 1, 0, 0, 0, 594, 596, 1, 0, 0, 0, 595, 593, 1, 0, 0, 0, 596, 597,
		5, 17, 0, 0, 597, 83, 1, 0, 0, 0, 598, 614, 3, 88, 44, 0, 599, 614, 3,
		90, 45, 0, 600, 614, 3, 94, 47, 0, 601, 614, 3, 100, 50, 0, 602, 614, 3,
		82, 41, 0, 603, 614, 3, 102, 51, 0, 604, 614, 3, 104, 52, 0, 605, 614,
		3, 106, 53, 0, 606, 614, 3, 108, 54, 0, 607, 614, 3, 110, 55, 0, 608, 614,
		3, 112, 56, 0, 609, 614, 3, 114, 57, 0, 610, 614, 3, 96, 48, 0, 611, 614,
		3, 98, 49, 0, 612, 614, 3, 116, 58, 0, 613, 598, 1, 0, 0, 0, 613, 599,
		1, 0, 0, 0, 613, 600, 1, 0, 0, 0, 613, 601, 1, 0, 0, 0, 613, 602, 1, 0,
		0, 0, 613, 603, 1, 0, 0, 0, 613, 604, 1, 0, 0, 0, 613, 605, 1, 0, 0, 0,
		613, 606, 1, 0, 0, 0, 613, 607, 1, 0, 0, 0, 613, 608, 1, 0, 0, 0, 613,
		609, 1, 0, 0, 0, 613, 610, 1, 0, 0, 0, 613, 611, 1, 0, 0, 0, 613, 612,
		1, 0, 0, 0, 614, 85, 1, 0, 0, 0, 615, 616, 3, 126, 63, 0, 616, 617, 5,
		2, 0, 0, 617, 87, 1, 0, 0, 0, 618, 619, 5, 43, 0, 0, 619, 620, 5, 23, 0,
		0, 620, 621, 3, 126, 63, 0, 621, 622, 5, 24, 0, 0, 622, 625, 3, 84, 42,
		0, 623, 624, 5, 44, 0, 0, 624, 626, 3, 84, 42, 0, 625, 623, 1, 0, 0, 0,
		625, 626, 1, 0, 0, 0, 626, 89, 1, 0, 0, 0, 627, 628, 5, 45, 0, 0, 628,
		630, 3, 126, 63, 0, 629, 631, 3, 44, 22, 0, 630, 629, 1, 0, 0, 0, 630,
		631, 1, 0, 0, 0, 631, 632, 1, 0, 0, 0, 632, 634, 3, 82, 41, 0, 633, 635,
		3, 92, 46, 0, 634, 633, 1, 0, 0, 0, 635, 636, 1, 0, 0, 0, 636, 634, 1,
		0, 0, 0, 636, 637, 1, 0, 0, 0, 637, 91, 1, 0, 0, 0, 638, 643, 5, 46, 0,
		0, 639, 641, 3, 184, 92, 0, 640, 639, 1, 0, 0, 0, 640, 641, 1, 0, 0, 0,
		641, 642, 1, 0, 0, 0, 642, 644, 3, 54, 27, 0, 643, 640, 1, 0, 0, 0, 643,
		644, 1, 0, 0, 0, 644, 645, 1, 0, 0, 0, 645, 646, 3, 82, 41, 0, 646, 93,
		1, 0, 0, 0, 647, 648, 5, 47, 0, 0, 648, 649, 5, 23, 0, 0, 649, 650, 3,
		126, 63, 0, 650, 651, 5, 24, 0, 0, 651, 652, 3, 84, 42, 0, 652, 95, 1,
		0, 0, 0, 653, 656, 3, 118, 59, 0, 654, 656, 3, 86, 43, 0, 655, 653, 1,
		0, 0, 0, 655, 654, 1, 0, 0, 0, 656, 97, 1, 0, 0, 0, 657, 658, 5, 48, 0,
		0, 658, 659, 3, 82, 41, 0, 659, 99, 1, 0, 0, 0, 660, 661, 5, 27, 0, 0,
		661, 664, 5, 23, 0, 0, 662, 665, 3, 96, 48, 0, 663, 665, 5, 2, 0, 0, 664,
		662, 1, 0, 0, 0, 664, 663, 1, 0, 0, 0, 665, 668, 1, 0, 0, 0, 666, 669,
		3, 86, 43, 0, 667, 669, 5, 2, 0, 0, 668, 666, 1, 0, 0, 0, 668, 667, 1,
		0, 0, 0, 669, 671, 1, 0, 0, 0, 670, 672, 3, 126, 63, 0, 671, 670, 1, 0,
		0, 0, 671, 672, 1, 0, 0, 0, 672, 673, 1, 0, 0, 0, 673, 674, 5, 24, 0, 0,
		674, 675, 3, 84, 42, 0, 675, 101, 1, 0, 0, 0, 676, 678, 5, 49, 0, 0, 677,
		679, 5, 129, 0, 0, 678, 677, 1, 0, 0, 0, 678, 679, 1, 0, 0, 0, 679, 680,
		1, 0, 0, 0, 680, 681, 3, 140, 70, 0, 681, 103, 1, 0, 0, 0, 682, 683, 5,
		50, 0, 0, 683, 684, 3, 84, 42, 0, 684, 685, 5, 47, 0, 0, 685, 686, 5, 23,
		0, 0, 686, 687, 3, 126, 63, 0, 687, 688, 5, 24, 0, 0, 688, 689, 5, 2, 0,
		0, 689, 105, 1, 0, 0, 0, 690, 691, 5, 113, 0, 0, 691, 692, 5, 2, 0, 0,
		692, 107, 1, 0, 0, 0, 693, 694, 5, 110, 0, 0, 694, 695, 5, 2, 0, 0, 695,
		109, 1, 0, 0, 0, 696, 698, 5, 51, 0, 0, 697, 699, 3, 126, 63, 0, 698, 697,
		1, 0, 0, 0, 698, 699, 1, 0, 0, 0, 699, 700, 1, 0, 0, 0, 700, 701, 5, 2,
		0, 0, 701, 111, 1, 0, 0, 0, 702, 703, 5, 52, 0, 0, 703, 704, 5, 2, 0, 0,
		704, 113, 1, 0, 0, 0, 705, 706, 5, 53, 0, 0, 706, 707, 3, 138, 69, 0, 707,
		708, 5, 2, 0, 0, 708, 115, 1, 0, 0, 0, 709, 710, 5, 54, 0, 0, 710, 711,
		3, 138, 69, 0, 711, 712, 5, 2, 0, 0, 712, 117, 1, 0, 0, 0, 713, 714, 5,
		55, 0, 0, 714, 721, 3, 122, 61, 0, 715, 721, 3, 66, 33, 0, 716, 717, 5,
		23, 0, 0, 717, 718, 3, 120, 60, 0, 718, 719, 5, 24, 0, 0, 719, 721, 1,
		0, 0, 0, 720, 713, 1, 0, 0, 0, 720, 715, 1, 0, 0, 0, 720, 716, 1, 0, 0,
		0, 721, 724, 1, 0, 0, 0, 722, 723, 5, 10, 0, 0, 723, 725, 3, 126, 63, 0,
		724, 722, 1, 0, 0, 0, 724, 725, 1, 0, 0, 0, 725, 726, 1, 0, 0, 0, 726,
		727, 5, 2, 0, 0, 727, 119, 1, 0, 0, 0, 728, 730, 3, 66, 33, 0, 729, 728,
		1, 0, 0, 0, 729, 730, 1, 0, 0, 0, 730, 737, 1, 0, 0, 0, 731, 733, 5, 16,
		0, 0, 732, 734, 3, 66, 33, 0, 733, 732, 1, 0, 0, 0, 733, 734, 1, 0, 0,
		0, 734, 736, 1, 0, 0, 0, 735, 731, 1, 0, 0, 0, 736, 739, 1, 0, 0, 0, 737,
		735, 1, 0, 0, 0, 737, 738, 1, 0, 0, 0, 738, 121, 1, 0, 0, 0, 739, 737,
		1, 0, 0, 0, 740, 747, 5, 23, 0, 0, 741, 743, 3, 184, 92, 0, 742, 741, 1,
		0, 0, 0, 742, 743, 1, 0, 0, 0, 743, 744, 1, 0, 0, 0, 744, 746, 5, 16, 0,
		0, 745, 742, 1, 0, 0, 0, 746, 749, 1, 0, 0, 0, 747, 745, 1, 0, 0, 0, 747,
		748, 1, 0, 0, 0, 748, 751, 1, 0, 0, 0, 749, 747, 1, 0, 0, 0, 750, 752,
		3, 184, 92, 0, 751, 750, 1, 0, 0, 0, 751, 752, 1, 0, 0, 0, 752, 753, 1,
		0, 0, 0, 753, 754, 5, 24, 0, 0, 754, 123, 1, 0, 0, 0, 755, 756, 7, 4, 0,
		0, 756, 125, 1, 0, 0, 0, 757, 758, 6, 63, -1, 0, 758, 759, 5, 61, 0, 0,
		759, 776, 3, 68, 34, 0, 760, 761, 5, 23, 0, 0, 761, 762, 3, 126, 63, 0,
		762, 763, 5, 24, 0, 0, 763, 776, 1, 0, 0, 0, 764, 765, 7, 5, 0, 0, 765,
		776, 3, 126, 63, 19, 766, 767, 7, 6, 0, 0, 767, 776, 3, 126, 63, 18, 768,
		769, 7, 7, 0, 0, 769, 776, 3, 126, 63, 17, 770, 771, 5, 67, 0, 0, 771,
		776, 3, 126, 63, 16, 772, 773, 5, 5, 0, 0, 773, 776, 3, 126, 63, 15, 774,
		776, 3, 128, 64, 0, 775, 757, 1, 0, 0, 0, 775, 760, 1, 0, 0, 0, 775, 764,
		1, 0, 0, 0, 775, 766, 1, 0, 0, 0, 775, 768, 1, 0, 0, 0, 775, 770, 1, 0,
		0, 0, 775, 772, 1, 0, 0, 0, 775, 774, 1, 0, 0, 0, 776, 851, 1, 0, 0, 0,
		777, 778, 10, 14, 0, 0, 778, 779, 5, 68, 0, 0, 779, 850, 3, 126, 63, 15,
		780, 781, 10, 13, 0, 0, 781, 782, 7, 8, 0, 0, 782, 850, 3, 126, 63, 14,
		783, 784, 10, 12, 0, 0, 784, 785, 7, 6, 0, 0, 785, 850, 3, 126, 63, 13,
		786, 787, 10, 11, 0, 0, 787, 788, 7, 9, 0, 0, 788, 850, 3, 126, 63, 12,
		789, 790, 10, 10, 0, 0, 790, 791, 5, 73, 0, 0, 791, 850, 3, 126, 63, 11,
		792, 793, 10, 9, 0, 0, 793, 794, 5, 4, 0, 0, 794, 850, 3, 126, 63, 10,
		795, 796, 10, 8, 0, 0, 796, 797, 5, 74, 0, 0, 797, 850, 3, 126, 63, 9,
		798, 799, 10, 7, 0, 0, 799, 800, 7, 10, 0, 0, 800, 850, 3, 126, 63, 8,
		801, 802, 10, 6, 0, 0, 802, 803, 7, 11, 0, 0, 803, 850, 3, 126, 63, 7,
		804, 805, 10, 5, 0, 0, 805, 806, 5, 77, 0, 0, 806, 850, 3, 126, 63, 6,
		807, 808, 10, 4, 0, 0, 808, 809, 5, 3, 0, 0, 809, 850, 3, 126, 63, 5, 810,
		811, 10, 3, 0, 0, 811, 812, 5, 78, 0, 0, 812, 813, 3, 126, 63, 0, 813,
		814, 5, 62, 0, 0, 814, 815, 3, 126, 63, 4, 815, 850, 1, 0, 0, 0, 816, 817,
		10, 2, 0, 0, 817, 818, 7, 12, 0, 0, 818, 850, 3, 126, 63, 3, 819, 820,
		10, 27, 0, 0, 820, 850, 7, 5, 0, 0, 821, 822, 10, 25, 0, 0, 822, 823, 5,
		34, 0, 0, 823, 824, 3, 126, 63, 0, 824, 825, 5, 35, 0, 0, 825, 850, 1,
		0, 0, 0, 826, 827, 10, 24, 0, 0, 827, 829, 5, 34, 0, 0, 828, 830, 3, 126,
		63, 0, 829, 828, 1, 0, 0, 0, 829, 830, 1, 0, 0, 0, 830, 831, 1, 0, 0, 0,
		831, 833, 5, 62, 0, 0, 832, 834, 3, 126, 63, 0, 833, 832, 1, 0, 0, 0, 833,
		834, 1, 0, 0, 0, 834, 835, 1, 0, 0, 0, 835, 850, 5, 35, 0, 0, 836, 837,
		10, 23, 0, 0, 837, 838, 5, 37, 0, 0, 838, 850, 3, 184, 92, 0, 839, 840,
		10, 22, 0, 0, 840, 841, 5, 15, 0, 0, 841, 842, 3, 132, 66, 0, 842, 843,
		5, 17, 0, 0, 843, 850, 1, 0, 0, 0, 844, 845, 10, 21, 0, 0, 845, 846, 5,
		23, 0, 0, 846, 847, 3, 136, 68, 0, 847, 848, 5, 24, 0, 0, 848, 850, 1,
		0, 0, 0, 849, 777, 1, 0, 0, 0, 849, 780, 1, 0, 0, 0, 849, 783, 1, 0, 0,
		0, 849, 786, 1, 0, 0, 0, 849, 789, 1, 0, 0, 0, 849, 792, 1, 0, 0, 0, 849,
		795, 1, 0, 0, 0, 849, 798, 1, 0, 0, 0, 849, 801, 1, 0, 0, 0, 849, 804,
		1, 0, 0, 0, 849, 807, 1, 0, 0, 0, 849, 810, 1, 0, 0, 0, 849, 816, 1, 0,
		0, 0, 849, 819, 1, 0, 0, 0, 849, 821, 1, 0, 0, 0, 849, 826, 1, 0, 0, 0,
		849, 836, 1, 0, 0, 0, 849, 839, 1, 0, 0, 0, 849, 844, 1, 0, 0, 0, 850,
		853, 1, 0, 0, 0, 851, 849, 1, 0, 0, 0, 851, 852, 1, 0, 0, 0, 852, 127,
		1, 0, 0, 0, 853, 851, 1, 0, 0, 0, 854, 872, 5, 103, 0, 0, 855, 872, 3,
		182, 91, 0, 856, 872, 3, 186, 93, 0, 857, 872, 3, 190, 95, 0, 858, 861,
		3, 184, 92, 0, 859, 860, 5, 34, 0, 0, 860, 862, 5, 35, 0, 0, 861, 859,
		1, 0, 0, 0, 861, 862, 1, 0, 0, 0, 862, 872, 1, 0, 0, 0, 863, 872, 5, 123,
		0, 0, 864, 872, 5, 118, 0, 0, 865, 872, 3, 178, 89, 0, 866, 869, 3, 180,
		90, 0, 867, 868, 5, 34, 0, 0, 868, 870, 5, 35, 0, 0, 869, 867, 1, 0, 0,
		0, 869, 870, 1, 0, 0, 0, 870, 872, 1, 0, 0, 0, 871, 854, 1, 0, 0, 0, 871,
		855, 1, 0, 0, 0, 871, 856, 1, 0, 0, 0, 871, 857, 1, 0, 0, 0, 871, 858,
		1, 0, 0, 0, 871, 863, 1, 0, 0, 0, 871, 864, 1, 0, 0, 0, 871, 865, 1, 0,
		0, 0, 871, 866, 1, 0, 0, 0, 872, 129, 1, 0, 0, 0, 873, 878, 3, 126, 63,
		0, 874, 875, 5, 16, 0, 0, 875, 877, 3, 126, 63, 0, 876, 874, 1, 0, 0, 0,
		877, 880, 1, 0, 0, 0, 878, 876, 1, 0, 0, 0, 878, 879, 1, 0, 0, 0, 879,
		131, 1, 0, 0, 0, 880, 878, 1, 0, 0, 0, 881, 886, 3, 134, 67, 0, 882, 883,
		5, 16, 0, 0, 883, 885, 3, 134, 67, 0, 884, 882, 1, 0, 0, 0, 885, 888, 1,
		0, 0, 0, 886, 884, 1, 0, 0, 0, 886, 887, 1, 0, 0, 0, 887, 890, 1, 0, 0,
		0, 888, 886, 1, 0, 0, 0, 889, 891, 5, 16, 0, 0, 890, 889, 1, 0, 0, 0, 890,
		891, 1, 0, 0, 0, 891, 133, 1, 0, 0, 0, 892, 893, 3, 184, 92, 0, 893, 894,
		5, 62, 0, 0, 894, 895, 3, 126, 63, 0, 895, 135, 1, 0, 0, 0, 896, 898, 5,
		15, 0, 0, 897, 899, 3, 132, 66, 0, 898, 897, 1, 0, 0, 0, 898, 899, 1, 0,
		0, 0, 899, 900, 1, 0, 0, 0, 900, 905, 5, 17, 0, 0, 901, 903, 3, 130, 65,
		0, 902, 901, 1, 0, 0, 0, 902, 903, 1, 0, 0, 0, 903, 905, 1, 0, 0, 0, 904,
		896, 1, 0, 0, 0, 904, 902, 1, 0, 0, 0, 905, 137, 1, 0, 0, 0, 906, 907,
		3, 126, 63, 0, 907, 908, 5, 23, 0, 0, 908, 909, 3, 136, 68, 0, 909, 910,
		5, 24, 0, 0, 910, 139, 1, 0, 0, 0, 911, 915, 5, 15, 0, 0, 912, 914, 3,
		142, 71, 0, 913, 912, 1, 0, 0, 0, 914, 917, 1, 0, 0, 0, 915, 913, 1, 0,
		0, 0, 915, 916, 1, 0, 0, 0, 916, 918, 1, 0, 0, 0, 917, 915, 1, 0, 0, 0,
		918, 919, 5, 17, 0, 0, 919, 141, 1, 0, 0, 0, 920, 939, 3, 184, 92, 0, 921,
		939, 3, 140, 70, 0, 922, 939, 3, 144, 72, 0, 923, 939, 3, 150, 75, 0, 924,
		939, 3, 152, 76, 0, 925, 939, 3, 158, 79, 0, 926, 939, 3, 160, 80, 0, 927,
		939, 3, 162, 81, 0, 928, 939, 3, 166, 83, 0, 929, 939, 3, 170, 85, 0, 930,
		939, 3, 172, 86, 0, 931, 939, 5, 110, 0, 0, 932, 939, 5, 113, 0, 0, 933,
		939, 5, 114, 0, 0, 934, 939, 3, 176, 88, 0, 935, 939, 3, 182, 91, 0, 936,
		939, 3, 190, 95, 0, 937, 939, 3, 186, 93, 0, 938, 920, 1, 0, 0, 0, 938,
		921, 1, 0, 0, 0, 938, 922, 1, 0, 0, 0, 938, 923, 1, 0, 0, 0, 938, 924,
		1, 0, 0, 0, 938, 925, 1, 0, 0, 0, 938, 926, 1, 0, 0, 0, 938, 927, 1, 0,
		0, 0, 938, 928, 1, 0, 0, 0, 938, 929, 1, 0, 0, 0, 938, 930, 1, 0, 0, 0,
		938, 931, 1, 0, 0, 0, 938, 932, 1, 0, 0, 0, 938, 933, 1, 0, 0, 0, 938,
		934, 1, 0, 0, 0, 938, 935, 1, 0, 0, 0, 938, 936, 1, 0, 0, 0, 938, 937,
		1, 0, 0, 0, 939, 143, 1, 0, 0, 0, 940, 944, 3, 148, 74, 0, 941, 944, 3,
		174, 87, 0, 942, 944, 3, 146, 73, 0, 943, 940, 1, 0, 0, 0, 943, 941, 1,
		0, 0, 0, 943, 942, 1, 0, 0, 0, 944, 145, 1, 0, 0, 0, 945, 946, 3, 184,
		92, 0, 946, 947, 5, 37, 0, 0, 947, 948, 3, 184, 92, 0, 948, 147, 1, 0,
		0, 0, 949, 954, 5, 51, 0, 0, 950, 954, 5, 36, 0, 0, 951, 954, 5, 58, 0,
		0, 952, 954, 3, 184, 92, 0, 953, 949, 1, 0, 0, 0, 953, 950, 1, 0, 0, 0,
		953, 951, 1, 0, 0, 0, 953, 952, 1, 0, 0, 0, 954, 967, 1, 0, 0, 0, 955,
		957, 5, 23, 0, 0, 956, 958, 3, 144, 72, 0, 957, 956, 1, 0, 0, 0, 957, 958,
		1, 0, 0, 0, 958, 963, 1, 0, 0, 0, 959, 960, 5, 16, 0, 0, 960, 962, 3, 144,
		72, 0, 961, 959, 1, 0, 0, 0, 962, 965, 1, 0, 0, 0, 963, 961, 1, 0, 0, 0,
		963, 964, 1, 0, 0, 0, 964, 966, 1, 0, 0, 0, 965, 963, 1, 0, 0, 0, 966,
		968, 5, 24, 0, 0, 967, 955, 1, 0, 0, 0, 967, 968, 1, 0, 0, 0, 968, 149,
		1, 0, 0, 0, 969, 970, 5, 89, 0, 0, 970, 973, 3, 154, 77, 0, 971, 972, 5,
		90, 0, 0, 972, 974, 3, 144, 72, 0, 973, 971, 1, 0, 0, 0, 973, 974, 1, 0,
		0, 0, 974, 151, 1, 0, 0, 0, 975, 976, 3, 154, 77, 0, 976, 977, 5, 90, 0,
		0, 977, 978, 3, 144, 72, 0, 978, 153, 1, 0, 0, 0, 979, 986, 3, 184, 92,
		0, 980, 986, 3, 146, 73, 0, 981, 982, 5, 23, 0, 0, 982, 983, 3, 156, 78,
		0, 983, 984, 5, 24, 0, 0, 984, 986, 1, 0, 0, 0, 985, 979, 1, 0, 0, 0, 985,
		980, 1, 0, 0, 0, 985, 981, 1, 0, 0, 0, 986, 155, 1, 0, 0, 0, 987, 992,
		3, 184, 92, 0, 988, 989, 5, 16, 0, 0, 989, 991, 3, 184, 92, 0, 990, 988,
		1, 0, 0, 0, 991, 994, 1, 0, 0, 0, 992, 990, 1, 0, 0, 0, 992, 993, 1, 0,
		0, 0, 993, 157, 1, 0, 0, 0, 994, 992, 1, 0, 0, 0, 995, 996, 5, 91, 0, 0,
		996, 997, 3, 184, 92, 0, 997, 159, 1, 0, 0, 0, 998, 999, 3, 184, 92, 0,
		999, 1000, 5, 62, 0, 0, 1000, 161, 1, 0, 0, 0, 1001, 1002, 5, 92, 0, 0,
		1002, 1006, 3, 144, 72, 0, 1003, 1005, 3, 164, 82, 0, 1004, 1003, 1, 0,
		0, 0, 1005, 1008, 1, 0, 0, 0, 1006, 1004, 1, 0, 0, 0, 1006, 1007, 1, 0,
		0, 0, 1007, 163, 1, 0, 0, 0, 1008, 1006, 1, 0, 0, 0, 1009, 1010, 5, 93,
		0, 0, 1010, 1011, 3, 174, 87, 0, 1011, 1012, 3, 140, 70, 0, 1012, 1016,
		1, 0, 0, 0, 1013, 1014, 5, 94, 0, 0, 1014, 1016, 3, 140, 70, 0, 1015, 1009,
		1, 0, 0, 0, 1015, 1013, 1, 0, 0, 0, 1016, 165, 1, 0, 0, 0, 1017, 1018,
		5, 30, 0, 0, 1018, 1019, 3, 184, 92, 0, 1019, 1021, 5, 23, 0, 0, 1020,
		1022, 3, 156, 78, 0, 1021, 1020, 1, 0, 0, 0, 1021, 1022, 1, 0, 0, 0, 1022,
		1023, 1, 0, 0, 0, 1023, 1025, 5, 24, 0, 0, 1024, 1026, 3, 168, 84, 0, 1025,
		1024, 1, 0, 0, 0, 1025, 1026, 1, 0, 0, 0, 1026, 1027, 1, 0, 0, 0, 1027,
		1028, 3, 140, 70, 0, 1028, 167, 1, 0, 0, 0, 1029, 1030, 5, 95, 0, 0, 1030,
		1031, 3, 156, 78, 0, 1031, 169, 1, 0, 0, 0, 1032, 1035, 5, 27, 0, 0, 1033,
		1036, 3, 140, 70, 0, 1034, 1036, 3, 144, 72, 0, 1035, 1033, 1, 0, 0, 0,
		1035, 1034, 1, 0, 0, 0, 1036, 1037, 1, 0, 0, 0, 1037, 1040, 3, 144, 72,
		0, 1038, 1041, 3, 140, 70, 0, 1039, 1041, 3, 144, 72, 0, 1040, 1038, 1,
		0, 0, 0, 1040, 1039, 1, 0, 0, 0, 1041, 1042, 1, 0, 0, 0, 1042, 1043, 3,
		140, 70, 0, 1043, 171, 1, 0, 0, 0, 1044, 1045, 5, 43, 0, 0, 1045, 1046,
		3, 144, 72, 0, 1046, 1047, 3, 140, 70, 0, 1047, 173, 1, 0, 0, 0, 1048,
		1053, 3, 190, 95, 0, 1049, 1053, 5, 104, 0, 0, 1050, 1053, 5, 105, 0, 0,
		1051, 1053, 3, 186, 93, 0, 1052, 1048, 1, 0, 0, 0, 1052, 1049, 1, 0, 0,
		0, 1052, 1050, 1, 0, 0, 0, 1052, 1051, 1, 0, 0, 0, 1053, 175, 1, 0, 0,
		0, 1054, 1055, 5, 49, 0, 0, 1055, 1056, 3, 184, 92, 0, 1056, 1057, 3, 140,
		70, 0, 1057, 177, 1, 0, 0, 0, 1058, 1060, 5, 23, 0, 0, 1059, 1061, 3, 126,
		63, 0, 1060, 1059, 1, 0, 0, 0, 1060, 1061, 1, 0, 0, 0, 1061, 1068, 1, 0,
		0, 0, 1062, 1064, 5, 16, 0, 0, 1063, 1065, 3, 126, 63, 0, 1064, 1063, 1,
		0, 0, 0, 1064, 1065, 1, 0, 0, 0, 1065, 1067, 1, 0, 0, 0, 1066, 1062, 1,
		0, 0, 0, 1067, 1070, 1, 0, 0, 0, 1068, 1066, 1, 0, 0, 0, 1068, 1069, 1,
		0, 0, 0, 1069, 1071, 1, 0, 0, 0, 1070, 1068, 1, 0, 0, 0, 1071, 1085, 5,
		24, 0, 0, 1072, 1081, 5, 34, 0, 0, 1073, 1078, 3, 126, 63, 0, 1074, 1075,
		5, 16, 0, 0, 1075, 1077, 3, 126, 63, 0, 1076, 1074, 1, 0, 0, 0, 1077, 1080,
		1, 0, 0, 0, 1078, 1076, 1, 0, 0, 0, 1078, 1079, 1, 0, 0, 0, 1079, 1082,
		1, 0, 0, 0, 1080, 1078, 1, 0, 0, 0, 1081, 1073, 1, 0, 0, 0, 1081, 1082,
		1, 0, 0, 0, 1082, 1083, 1, 0, 0, 0, 1083, 1085, 5, 35, 0, 0, 1084, 1058,
		1, 0, 0, 0, 1084, 1072, 1, 0, 0, 0, 1085, 179, 1, 0, 0, 0, 1086, 1089,
		3, 124, 62, 0, 1087, 1089, 3, 70, 35, 0, 1088, 1086, 1, 0, 0, 0, 1088,
		1087, 1, 0, 0, 0, 1089, 181, 1, 0, 0, 0, 1090, 1092, 7, 13, 0, 0, 1091,
		1093, 5, 106, 0, 0, 1092, 1091, 1, 0, 0, 0, 1092, 1093, 1, 0, 0, 0, 1093,
		183, 1, 0, 0, 0, 1094, 1095, 7, 14, 0, 0, 1095, 185, 1, 0, 0, 0, 1096,
		1098, 5, 107, 0, 0, 1097, 1096, 1, 0, 0, 0, 1098, 1099, 1, 0, 0, 0, 1099,
		1097, 1, 0, 0, 0, 1099, 1100, 1, 0, 0, 0, 1100, 187, 1, 0, 0, 0, 1101,
		1113, 5, 97, 0, 0, 1102, 1103, 5, 23, 0, 0, 1103, 1108, 3, 70, 35, 0, 1104,
		1105, 5, 16, 0, 0, 1105, 1107, 3, 70, 35, 0, 1106, 1104, 1, 0, 0, 0, 1107,
		1110, 1, 0, 0, 0, 1108, 1106, 1, 0, 0, 0, 1108, 1109, 1, 0, 0, 0, 1109,
		1111, 1, 0, 0, 0, 1110, 1108, 1, 0, 0, 0, 1111, 1112, 5, 24, 0, 0, 1112,
		1114, 1, 0, 0, 0, 1113, 1102, 1, 0, 0, 0, 1113, 1114, 1, 0, 0, 0, 1114,
		189, 1, 0, 0, 0, 1115, 1117, 5, 129, 0, 0, 1116, 1115, 1, 0, 0, 0, 1117,
		1118, 1, 0, 0, 0, 1118, 1116, 1, 0, 0, 0, 1118, 1119, 1, 0, 0, 0, 1119,
		191, 1, 0, 0, 0, 126, 200, 202, 216, 220, 225, 231, 235, 238, 243, 249,
		256, 260, 273, 281, 286, 296, 299, 305, 313, 316, 326, 335, 337, 343, 364,
		378, 381, 388, 392, 394, 399, 404, 407, 413, 417, 421, 426, 439, 441, 448,
		458, 464, 475, 478, 484, 487, 495, 498, 504, 507, 515, 518, 524, 528, 539,
		544, 549, 557, 562, 576, 578, 583, 593, 613, 625, 630, 636, 640, 643, 655,
		664, 668, 671, 678, 698, 720, 724, 729, 733, 737, 742, 747, 751, 775, 829,
		833, 849, 851, 861, 869, 871, 878, 886, 890, 898, 902, 904, 915, 938, 943,
		953, 957, 963, 967, 973, 985, 992, 1006, 1015, 1021, 1025, 1035, 1040,
		1052, 1060, 1064, 1068, 1078, 1081, 1084, 1088, 1092, 1099, 1108, 1113,
		1118,
	}
	deserializer := antlr.NewATNDeserializer(nil)
	staticData.atn = deserializer.Deserialize(staticData.serializedATN)
	atn := staticData.atn
	staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
	decisionToDFA := staticData.decisionToDFA
	for index, state := range atn.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(state, index)
	}
}

// SolidityParserInit initializes any static state used to implement SolidityParser. By default the
// static state used to implement the parser is lazily initialized during the first call to
// NewSolidityParser(). You can call this function if you wish to initialize the static state ahead
// of time.
func SolidityParserInit() {
	staticData := &SolidityParserStaticData
	staticData.once.Do(solidityParserInit)
}

// NewSolidityParser produces a new parser instance for the optional input antlr.TokenStream.
func NewSolidityParser(input antlr.TokenStream) *SolidityParser {
	SolidityParserInit()
	this := new(SolidityParser)
	this.BaseParser = antlr.NewBaseParser(input)
	staticData := &SolidityParserStaticData
	this.Interpreter = antlr.NewParserATNSimulator(this, staticData.atn, staticData.decisionToDFA, staticData.PredictionContextCache)
	this.RuleNames = staticData.RuleNames
	this.LiteralNames = staticData.LiteralNames
	this.SymbolicNames = staticData.SymbolicNames
	this.GrammarFileName = "Solidity.g4"

	return this
}

// SolidityParser tokens.
const (
	SolidityParserEOF                   = antlr.TokenEOF
	SolidityParserT__0                  = 1
	SolidityParserT__1                  = 2
	SolidityParserT__2                  = 3
	SolidityParserT__3                  = 4
	SolidityParserT__4                  = 5
	SolidityParserT__5                  = 6
	SolidityParserT__6                  = 7
	SolidityParserT__7                  = 8
	SolidityParserT__8                  = 9
	SolidityParserT__9                  = 10
	SolidityParserT__10                 = 11
	SolidityParserT__11                 = 12
	SolidityParserT__12                 = 13
	SolidityParserT__13                 = 14
	SolidityParserT__14                 = 15
	SolidityParserT__15                 = 16
	SolidityParserT__16                 = 17
	SolidityParserT__17                 = 18
	SolidityParserT__18                 = 19
	SolidityParserT__19                 = 20
	SolidityParserT__20                 = 21
	SolidityParserT__21                 = 22
	SolidityParserT__22                 = 23
	SolidityParserT__23                 = 24
	SolidityParserT__24                 = 25
	SolidityParserT__25                 = 26
	SolidityParserT__26                 = 27
	SolidityParserT__27                 = 28
	SolidityParserT__28                 = 29
	SolidityParserT__29                 = 30
	SolidityParserT__30                 = 31
	SolidityParserT__31                 = 32
	SolidityParserT__32                 = 33
	SolidityParserT__33                 = 34
	SolidityParserT__34                 = 35
	SolidityParserT__35                 = 36
	SolidityParserT__36                 = 37
	SolidityParserT__37                 = 38
	SolidityParserT__38                 = 39
	SolidityParserT__39                 = 40
	SolidityParserT__40                 = 41
	SolidityParserT__41                 = 42
	SolidityParserT__42                 = 43
	SolidityParserT__43                 = 44
	SolidityParserT__44                 = 45
	SolidityParserT__45                 = 46
	SolidityParserT__46                 = 47
	SolidityParserT__47                 = 48
	SolidityParserT__48                 = 49
	SolidityParserT__49                 = 50
	SolidityParserT__50                 = 51
	SolidityParserT__51                 = 52
	SolidityParserT__52                 = 53
	SolidityParserT__53                 = 54
	SolidityParserT__54                 = 55
	SolidityParserT__55                 = 56
	SolidityParserT__56                 = 57
	SolidityParserT__57                 = 58
	SolidityParserT__58                 = 59
	SolidityParserT__59                 = 60
	SolidityParserT__60                 = 61
	SolidityParserT__61                 = 62
	SolidityParserT__62                 = 63
	SolidityParserT__63                 = 64
	SolidityParserT__64                 = 65
	SolidityParserT__65                 = 66
	SolidityParserT__66                 = 67
	SolidityParserT__67                 = 68
	SolidityParserT__68                 = 69
	SolidityParserT__69                 = 70
	SolidityParserT__70                 = 71
	SolidityParserT__71                 = 72
	SolidityParserT__72                 = 73
	SolidityParserT__73                 = 74
	SolidityParserT__74                 = 75
	SolidityParserT__75                 = 76
	SolidityParserT__76                 = 77
	SolidityParserT__77                 = 78
	SolidityParserT__78                 = 79
	SolidityParserT__79                 = 80
	SolidityParserT__80                 = 81
	SolidityParserT__81                 = 82
	SolidityParserT__82                 = 83
	SolidityParserT__83                 = 84
	SolidityParserT__84                 = 85
	SolidityParserT__85                 = 86
	SolidityParserT__86                 = 87
	SolidityParserT__87                 = 88
	SolidityParserT__88                 = 89
	SolidityParserT__89                 = 90
	SolidityParserT__90                 = 91
	SolidityParserT__91                 = 92
	SolidityParserT__92                 = 93
	SolidityParserT__93                 = 94
	SolidityParserT__94                 = 95
	SolidityParserT__95                 = 96
	SolidityParserT__96                 = 97
	SolidityParserInt                   = 98
	SolidityParserUint                  = 99
	SolidityParserByte                  = 100
	SolidityParserFixed                 = 101
	SolidityParserUfixed                = 102
	SolidityParserBooleanLiteral        = 103
	SolidityParserDecimalNumber         = 104
	SolidityParserHexNumber             = 105
	SolidityParserNumberUnit            = 106
	SolidityParserHexLiteralFragment    = 107
	SolidityParserReservedKeyword       = 108
	SolidityParserAnonymousKeyword      = 109
	SolidityParserBreakKeyword          = 110
	SolidityParserConstantKeyword       = 111
	SolidityParserImmutableKeyword      = 112
	SolidityParserContinueKeyword       = 113
	SolidityParserLeaveKeyword          = 114
	SolidityParserExternalKeyword       = 115
	SolidityParserIndexedKeyword        = 116
	SolidityParserInternalKeyword       = 117
	SolidityParserPayableKeyword        = 118
	SolidityParserPrivateKeyword        = 119
	SolidityParserPublicKeyword         = 120
	SolidityParserVirtualKeyword        = 121
	SolidityParserPureKeyword           = 122
	SolidityParserTypeKeyword           = 123
	SolidityParserViewKeyword           = 124
	SolidityParserConstructorKeyword    = 125
	SolidityParserFallbackKeyword       = 126
	SolidityParserReceiveKeyword        = 127
	SolidityParserIdentifier            = 128
	SolidityParserStringLiteralFragment = 129
	SolidityParserVersionLiteral        = 130
	SolidityParserWS                    = 131
	SolidityParserCOMMENT               = 132
	SolidityParserLINE_COMMENT          = 133
)

// SolidityParser rules.
const (
	SolidityParserRULE_sourceUnit                   = 0
	SolidityParserRULE_pragmaDirective              = 1
	SolidityParserRULE_pragmaName                   = 2
	SolidityParserRULE_pragmaValue                  = 3
	SolidityParserRULE_version                      = 4
	SolidityParserRULE_versionOperator              = 5
	SolidityParserRULE_versionConstraint            = 6
	SolidityParserRULE_importDeclaration            = 7
	SolidityParserRULE_importDirective              = 8
	SolidityParserRULE_importPath                   = 9
	SolidityParserRULE_contractDefinition           = 10
	SolidityParserRULE_inheritanceSpecifier         = 11
	SolidityParserRULE_contractPart                 = 12
	SolidityParserRULE_stateVariableDeclaration     = 13
	SolidityParserRULE_fileLevelConstant            = 14
	SolidityParserRULE_customErrorDefinition        = 15
	SolidityParserRULE_usingForDeclaration          = 16
	SolidityParserRULE_structDefinition             = 17
	SolidityParserRULE_modifierDefinition           = 18
	SolidityParserRULE_modifierInvocation           = 19
	SolidityParserRULE_functionDefinition           = 20
	SolidityParserRULE_functionDescriptor           = 21
	SolidityParserRULE_returnParameters             = 22
	SolidityParserRULE_modifierList                 = 23
	SolidityParserRULE_eventDefinition              = 24
	SolidityParserRULE_enumValue                    = 25
	SolidityParserRULE_enumDefinition               = 26
	SolidityParserRULE_parameterList                = 27
	SolidityParserRULE_parameter                    = 28
	SolidityParserRULE_eventParameterList           = 29
	SolidityParserRULE_eventParameter               = 30
	SolidityParserRULE_functionTypeParameterList    = 31
	SolidityParserRULE_functionTypeParameter        = 32
	SolidityParserRULE_variableDeclaration          = 33
	SolidityParserRULE_typeName                     = 34
	SolidityParserRULE_userDefinedTypeName          = 35
	SolidityParserRULE_mappingKey                   = 36
	SolidityParserRULE_mapping                      = 37
	SolidityParserRULE_functionTypeName             = 38
	SolidityParserRULE_storageLocation              = 39
	SolidityParserRULE_stateMutability              = 40
	SolidityParserRULE_block                        = 41
	SolidityParserRULE_statement                    = 42
	SolidityParserRULE_expressionStatement          = 43
	SolidityParserRULE_ifStatement                  = 44
	SolidityParserRULE_tryStatement                 = 45
	SolidityParserRULE_catchClause                  = 46
	SolidityParserRULE_whileStatement               = 47
	SolidityParserRULE_simpleStatement              = 48
	SolidityParserRULE_uncheckedStatement           = 49
	SolidityParserRULE_forStatement                 = 50
	SolidityParserRULE_inlineAssemblyStatement      = 51
	SolidityParserRULE_doWhileStatement             = 52
	SolidityParserRULE_continueStatement            = 53
	SolidityParserRULE_breakStatement               = 54
	SolidityParserRULE_returnStatement              = 55
	SolidityParserRULE_throwStatement               = 56
	SolidityParserRULE_emitStatement                = 57
	SolidityParserRULE_revertStatement              = 58
	SolidityParserRULE_variableDeclarationStatement = 59
	SolidityParserRULE_variableDeclarationList      = 60
	SolidityParserRULE_identifierList               = 61
	SolidityParserRULE_elementaryTypeName           = 62
	SolidityParserRULE_expression                   = 63
	SolidityParserRULE_primaryExpression            = 64
	SolidityParserRULE_expressionList               = 65
	SolidityParserRULE_nameValueList                = 66
	SolidityParserRULE_nameValue                    = 67
	SolidityParserRULE_functionCallArguments        = 68
	SolidityParserRULE_functionCall                 = 69
	SolidityParserRULE_assemblyBlock                = 70
	SolidityParserRULE_assemblyItem                 = 71
	SolidityParserRULE_assemblyExpression           = 72
	SolidityParserRULE_assemblyMember               = 73
	SolidityParserRULE_assemblyCall                 = 74
	SolidityParserRULE_assemblyLocalDefinition      = 75
	SolidityParserRULE_assemblyAssignment           = 76
	SolidityParserRULE_assemblyIdentifierOrList     = 77
	SolidityParserRULE_assemblyIdentifierList       = 78
	SolidityParserRULE_assemblyStackAssignment      = 79
	SolidityParserRULE_labelDefinition              = 80
	SolidityParserRULE_assemblySwitch               = 81
	SolidityParserRULE_assemblyCase                 = 82
	SolidityParserRULE_assemblyFunctionDefinition   = 83
	SolidityParserRULE_assemblyFunctionReturns      = 84
	SolidityParserRULE_assemblyFor                  = 85
	SolidityParserRULE_assemblyIf                   = 86
	SolidityParserRULE_assemblyLiteral              = 87
	SolidityParserRULE_subAssembly                  = 88
	SolidityParserRULE_tupleExpression              = 89
	SolidityParserRULE_typeNameExpression           = 90
	SolidityParserRULE_numberLiteral                = 91
	SolidityParserRULE_identifier                   = 92
	SolidityParserRULE_hexLiteral                   = 93
	SolidityParserRULE_overrideSpecifier            = 94
	SolidityParserRULE_stringLiteral                = 95
)

// ISourceUnitContext is an interface to support dynamic dispatch.
type ISourceUnitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EOF() antlr.TerminalNode
	AllPragmaDirective() []IPragmaDirectiveContext
	PragmaDirective(i int) IPragmaDirectiveContext
	AllImportDirective() []IImportDirectiveContext
	ImportDirective(i int) IImportDirectiveContext
	AllContractDefinition() []IContractDefinitionContext
	ContractDefinition(i int) IContractDefinitionContext
	AllEnumDefinition() []IEnumDefinitionContext
	EnumDefinition(i int) IEnumDefinitionContext
	AllStructDefinition() []IStructDefinitionContext
	StructDefinition(i int) IStructDefinitionContext
	AllFunctionDefinition() []IFunctionDefinitionContext
	FunctionDefinition(i int) IFunctionDefinitionContext
	AllFileLevelConstant() []IFileLevelConstantContext
	FileLevelConstant(i int) IFileLevelConstantContext
	AllCustomErrorDefinition() []ICustomErrorDefinitionContext
	CustomErrorDefinition(i int) ICustomErrorDefinitionContext

	// IsSourceUnitContext differentiates from other interfaces.
	IsSourceUnitContext()
}

type SourceUnitContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySourceUnitContext() *SourceUnitContext {
	var p = new(SourceUnitContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_sourceUnit
	return p
}

func InitEmptySourceUnitContext(p *SourceUnitContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_sourceUnit
}

func (*SourceUnitContext) IsSourceUnitContext() {}

func NewSourceUnitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SourceUnitContext {
	var p = new(SourceUnitContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_sourceUnit

	return p
}

func (s *SourceUnitContext) GetParser() antlr.Parser { return s.parser }

func (s *SourceUnitContext) EOF() antlr.TerminalNode {
	return s.GetToken(SolidityParserEOF, 0)
}

func (s *SourceUnitContext) AllPragmaDirective() []IPragmaDirectiveContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPragmaDirectiveContext); ok {
			len++
		}
	}

	tst := make([]IPragmaDirectiveContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPragmaDirectiveContext); ok {
			tst[i] = t.(IPragmaDirectiveContext)
			i++
		}
	}

	return tst
}

func (s *SourceUnitContext) PragmaDirective(i int) IPragmaDirectiveContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPragmaDirectiveContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPragmaDirectiveContext)
}

func (s *SourceUnitContext) AllImportDirective() []IImportDirectiveContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IImportDirectiveContext); ok {
			len++
		}
	}

	tst := make([]IImportDirectiveContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IImportDirectiveContext); ok {
			tst[i] = t.(IImportDirectiveContext)
			i++
		}
	}

	return tst
}

func (s *SourceUnitContext) ImportDirective(i int) IImportDirectiveContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportDirectiveContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportDirectiveContext)
}

func (s *SourceUnitContext) AllContractDefinition() []IContractDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IContractDefinitionContext); ok {
			len++
		}
	}

	tst := make([]IContractDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IContractDefinitionContext); ok {
			tst[i] = t.(IContractDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *SourceUnitContext) ContractDefinition(i int) IContractDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IContractDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IContractDefinitionContext)
}

func (s *SourceUnitContext) AllEnumDefinition() []IEnumDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEnumDefinitionContext); ok {
			len++
		}
	}

	tst := make([]IEnumDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEnumDefinitionContext); ok {
			tst[i] = t.(IEnumDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *SourceUnitContext) EnumDefinition(i int) IEnumDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumDefinitionContext)
}

func (s *SourceUnitContext) AllStructDefinition() []IStructDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStructDefinitionContext); ok {
			len++
		}
	}

	tst := make([]IStructDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStructDefinitionContext); ok {
			tst[i] = t.(IStructDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *SourceUnitContext) StructDefinition(i int) IStructDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStructDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStructDefinitionContext)
}

func (s *SourceUnitContext) AllFunctionDefinition() []IFunctionDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFunctionDefinitionContext); ok {
			len++
		}
	}

	tst := make([]IFunctionDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFunctionDefinitionContext); ok {
			tst[i] = t.(IFunctionDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *SourceUnitContext) FunctionDefinition(i int) IFunctionDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionDefinitionContext)
}

func (s *SourceUnitContext) AllFileLevelConstant() []IFileLevelConstantContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFileLevelConstantContext); ok {
			len++
		}
	}

	tst := make([]IFileLevelConstantContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFileLevelConstantContext); ok {
			tst[i] = t.(IFileLevelConstantContext)
			i++
		}
	}

	return tst
}

func (s *SourceUnitContext) FileLevelConstant(i int) IFileLevelConstantContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFileLevelConstantContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFileLevelConstantContext)
}

func (s *SourceUnitContext) AllCustomErrorDefinition() []ICustomErrorDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICustomErrorDefinitionContext); ok {
			len++
		}
	}

	tst := make([]ICustomErrorDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICustomErrorDefinitionContext); ok {
			tst[i] = t.(ICustomErrorDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *SourceUnitContext) CustomErrorDefinition(i int) ICustomErrorDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICustomErrorDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICustomErrorDefinitionContext)
}

func (s *SourceUnitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SourceUnitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SourceUnitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterSourceUnit(s)
	}
}

func (s *SourceUnitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitSourceUnit(s)
	}
}

func (p *SolidityParser) SourceUnit() (localctx ISourceUnitContext) {
	localctx = NewSourceUnitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, SolidityParserRULE_sourceUnit)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(202)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&558451105407455234) != 0) || ((int64((_la-96)) & ^0x3f) == 0 && ((int64(1)<<(_la-96))&8057520253) != 0) {
		p.SetState(200)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 0, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(192)
				p.PragmaDirective()
			}

		case 2:
			{
				p.SetState(193)
				p.ImportDirective()
			}

		case 3:
			{
				p.SetState(194)
				p.ContractDefinition()
			}

		case 4:
			{
				p.SetState(195)
				p.EnumDefinition()
			}

		case 5:
			{
				p.SetState(196)
				p.StructDefinition()
			}

		case 6:
			{
				p.SetState(197)
				p.FunctionDefinition()
			}

		case 7:
			{
				p.SetState(198)
				p.FileLevelConstant()
			}

		case 8:
			{
				p.SetState(199)
				p.CustomErrorDefinition()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

		p.SetState(204)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(205)
		p.Match(SolidityParserEOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPragmaDirectiveContext is an interface to support dynamic dispatch.
type IPragmaDirectiveContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PragmaName() IPragmaNameContext
	PragmaValue() IPragmaValueContext

	// IsPragmaDirectiveContext differentiates from other interfaces.
	IsPragmaDirectiveContext()
}

type PragmaDirectiveContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPragmaDirectiveContext() *PragmaDirectiveContext {
	var p = new(PragmaDirectiveContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_pragmaDirective
	return p
}

func InitEmptyPragmaDirectiveContext(p *PragmaDirectiveContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_pragmaDirective
}

func (*PragmaDirectiveContext) IsPragmaDirectiveContext() {}

func NewPragmaDirectiveContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PragmaDirectiveContext {
	var p = new(PragmaDirectiveContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_pragmaDirective

	return p
}

func (s *PragmaDirectiveContext) GetParser() antlr.Parser { return s.parser }

func (s *PragmaDirectiveContext) PragmaName() IPragmaNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPragmaNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPragmaNameContext)
}

func (s *PragmaDirectiveContext) PragmaValue() IPragmaValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPragmaValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPragmaValueContext)
}

func (s *PragmaDirectiveContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PragmaDirectiveContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PragmaDirectiveContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterPragmaDirective(s)
	}
}

func (s *PragmaDirectiveContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitPragmaDirective(s)
	}
}

func (p *SolidityParser) PragmaDirective() (localctx IPragmaDirectiveContext) {
	localctx = NewPragmaDirectiveContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, SolidityParserRULE_pragmaDirective)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(207)
		p.Match(SolidityParserT__0)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(208)
		p.PragmaName()
	}
	{
		p.SetState(209)
		p.PragmaValue()
	}
	{
		p.SetState(210)
		p.Match(SolidityParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPragmaNameContext is an interface to support dynamic dispatch.
type IPragmaNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext

	// IsPragmaNameContext differentiates from other interfaces.
	IsPragmaNameContext()
}

type PragmaNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPragmaNameContext() *PragmaNameContext {
	var p = new(PragmaNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_pragmaName
	return p
}

func InitEmptyPragmaNameContext(p *PragmaNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_pragmaName
}

func (*PragmaNameContext) IsPragmaNameContext() {}

func NewPragmaNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PragmaNameContext {
	var p = new(PragmaNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_pragmaName

	return p
}

func (s *PragmaNameContext) GetParser() antlr.Parser { return s.parser }

func (s *PragmaNameContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PragmaNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PragmaNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PragmaNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterPragmaName(s)
	}
}

func (s *PragmaNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitPragmaName(s)
	}
}

func (p *SolidityParser) PragmaName() (localctx IPragmaNameContext) {
	localctx = NewPragmaNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, SolidityParserRULE_pragmaName)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(212)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPragmaValueContext is an interface to support dynamic dispatch.
type IPragmaValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Version() IVersionContext
	Expression() IExpressionContext

	// IsPragmaValueContext differentiates from other interfaces.
	IsPragmaValueContext()
}

type PragmaValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPragmaValueContext() *PragmaValueContext {
	var p = new(PragmaValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_pragmaValue
	return p
}

func InitEmptyPragmaValueContext(p *PragmaValueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_pragmaValue
}

func (*PragmaValueContext) IsPragmaValueContext() {}

func NewPragmaValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PragmaValueContext {
	var p = new(PragmaValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_pragmaValue

	return p
}

func (s *PragmaValueContext) GetParser() antlr.Parser { return s.parser }

func (s *PragmaValueContext) Version() IVersionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVersionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVersionContext)
}

func (s *PragmaValueContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PragmaValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PragmaValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PragmaValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterPragmaValue(s)
	}
}

func (s *PragmaValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitPragmaValue(s)
	}
}

func (p *SolidityParser) PragmaValue() (localctx IPragmaValueContext) {
	localctx = NewPragmaValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, SolidityParserRULE_pragmaValue)
	p.SetState(216)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 2, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(214)
			p.Version()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(215)
			p.expression(0)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVersionContext is an interface to support dynamic dispatch.
type IVersionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllVersionConstraint() []IVersionConstraintContext
	VersionConstraint(i int) IVersionConstraintContext

	// IsVersionContext differentiates from other interfaces.
	IsVersionContext()
}

type VersionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVersionContext() *VersionContext {
	var p = new(VersionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_version
	return p
}

func InitEmptyVersionContext(p *VersionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_version
}

func (*VersionContext) IsVersionContext() {}

func NewVersionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VersionContext {
	var p = new(VersionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_version

	return p
}

func (s *VersionContext) GetParser() antlr.Parser { return s.parser }

func (s *VersionContext) AllVersionConstraint() []IVersionConstraintContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVersionConstraintContext); ok {
			len++
		}
	}

	tst := make([]IVersionConstraintContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVersionConstraintContext); ok {
			tst[i] = t.(IVersionConstraintContext)
			i++
		}
	}

	return tst
}

func (s *VersionContext) VersionConstraint(i int) IVersionConstraintContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVersionConstraintContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVersionConstraintContext)
}

func (s *VersionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VersionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VersionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterVersion(s)
	}
}

func (s *VersionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitVersion(s)
	}
}

func (p *SolidityParser) Version() (localctx IVersionContext) {
	localctx = NewVersionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, SolidityParserRULE_version)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(218)
		p.VersionConstraint()
	}
	p.SetState(225)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&2040) != 0) || _la == SolidityParserDecimalNumber || _la == SolidityParserVersionLiteral {
		p.SetState(220)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SolidityParserT__2 {
			{
				p.SetState(219)
				p.Match(SolidityParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(222)
			p.VersionConstraint()
		}

		p.SetState(227)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVersionOperatorContext is an interface to support dynamic dispatch.
type IVersionOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsVersionOperatorContext differentiates from other interfaces.
	IsVersionOperatorContext()
}

type VersionOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVersionOperatorContext() *VersionOperatorContext {
	var p = new(VersionOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_versionOperator
	return p
}

func InitEmptyVersionOperatorContext(p *VersionOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_versionOperator
}

func (*VersionOperatorContext) IsVersionOperatorContext() {}

func NewVersionOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VersionOperatorContext {
	var p = new(VersionOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_versionOperator

	return p
}

func (s *VersionOperatorContext) GetParser() antlr.Parser { return s.parser }
func (s *VersionOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VersionOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VersionOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterVersionOperator(s)
	}
}

func (s *VersionOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitVersionOperator(s)
	}
}

func (p *SolidityParser) VersionOperator() (localctx IVersionOperatorContext) {
	localctx = NewVersionOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, SolidityParserRULE_versionOperator)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(228)
		_la = p.GetTokenStream().LA(1)

		if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&2032) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVersionConstraintContext is an interface to support dynamic dispatch.
type IVersionConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VersionLiteral() antlr.TerminalNode
	VersionOperator() IVersionOperatorContext
	DecimalNumber() antlr.TerminalNode

	// IsVersionConstraintContext differentiates from other interfaces.
	IsVersionConstraintContext()
}

type VersionConstraintContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVersionConstraintContext() *VersionConstraintContext {
	var p = new(VersionConstraintContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_versionConstraint
	return p
}

func InitEmptyVersionConstraintContext(p *VersionConstraintContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_versionConstraint
}

func (*VersionConstraintContext) IsVersionConstraintContext() {}

func NewVersionConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VersionConstraintContext {
	var p = new(VersionConstraintContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_versionConstraint

	return p
}

func (s *VersionConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *VersionConstraintContext) VersionLiteral() antlr.TerminalNode {
	return s.GetToken(SolidityParserVersionLiteral, 0)
}

func (s *VersionConstraintContext) VersionOperator() IVersionOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVersionOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVersionOperatorContext)
}

func (s *VersionConstraintContext) DecimalNumber() antlr.TerminalNode {
	return s.GetToken(SolidityParserDecimalNumber, 0)
}

func (s *VersionConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VersionConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VersionConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterVersionConstraint(s)
	}
}

func (s *VersionConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitVersionConstraint(s)
	}
}

func (p *SolidityParser) VersionConstraint() (localctx IVersionConstraintContext) {
	localctx = NewVersionConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, SolidityParserRULE_versionConstraint)
	var _la int

	p.SetState(238)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 7, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(231)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&2032) != 0 {
			{
				p.SetState(230)
				p.VersionOperator()
			}

		}
		{
			p.SetState(233)
			p.Match(SolidityParserVersionLiteral)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(235)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&2032) != 0 {
			{
				p.SetState(234)
				p.VersionOperator()
			}

		}
		{
			p.SetState(237)
			p.Match(SolidityParserDecimalNumber)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImportDeclarationContext is an interface to support dynamic dispatch.
type IImportDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext

	// IsImportDeclarationContext differentiates from other interfaces.
	IsImportDeclarationContext()
}

type ImportDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImportDeclarationContext() *ImportDeclarationContext {
	var p = new(ImportDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_importDeclaration
	return p
}

func InitEmptyImportDeclarationContext(p *ImportDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_importDeclaration
}

func (*ImportDeclarationContext) IsImportDeclarationContext() {}

func NewImportDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportDeclarationContext {
	var p = new(ImportDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_importDeclaration

	return p
}

func (s *ImportDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportDeclarationContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *ImportDeclarationContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ImportDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterImportDeclaration(s)
	}
}

func (s *ImportDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitImportDeclaration(s)
	}
}

func (p *SolidityParser) ImportDeclaration() (localctx IImportDeclarationContext) {
	localctx = NewImportDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, SolidityParserRULE_importDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(240)
		p.Identifier()
	}
	p.SetState(243)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SolidityParserT__10 {
		{
			p.SetState(241)
			p.Match(SolidityParserT__10)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(242)
			p.Identifier()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImportDirectiveContext is an interface to support dynamic dispatch.
type IImportDirectiveContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ImportPath() IImportPathContext
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	AllImportDeclaration() []IImportDeclarationContext
	ImportDeclaration(i int) IImportDeclarationContext

	// IsImportDirectiveContext differentiates from other interfaces.
	IsImportDirectiveContext()
}

type ImportDirectiveContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImportDirectiveContext() *ImportDirectiveContext {
	var p = new(ImportDirectiveContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_importDirective
	return p
}

func InitEmptyImportDirectiveContext(p *ImportDirectiveContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_importDirective
}

func (*ImportDirectiveContext) IsImportDirectiveContext() {}

func NewImportDirectiveContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportDirectiveContext {
	var p = new(ImportDirectiveContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_importDirective

	return p
}

func (s *ImportDirectiveContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportDirectiveContext) ImportPath() IImportPathContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportPathContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportPathContext)
}

func (s *ImportDirectiveContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *ImportDirectiveContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ImportDirectiveContext) AllImportDeclaration() []IImportDeclarationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IImportDeclarationContext); ok {
			len++
		}
	}

	tst := make([]IImportDeclarationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IImportDeclarationContext); ok {
			tst[i] = t.(IImportDeclarationContext)
			i++
		}
	}

	return tst
}

func (s *ImportDirectiveContext) ImportDeclaration(i int) IImportDeclarationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportDeclarationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportDeclarationContext)
}

func (s *ImportDirectiveContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportDirectiveContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportDirectiveContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterImportDirective(s)
	}
}

func (s *ImportDirectiveContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitImportDirective(s)
	}
}

func (p *SolidityParser) ImportDirective() (localctx IImportDirectiveContext) {
	localctx = NewImportDirectiveContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, SolidityParserRULE_importDirective)
	var _la int

	p.SetState(281)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 13, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(245)
			p.Match(SolidityParserT__11)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(246)
			p.ImportPath()
		}
		p.SetState(249)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SolidityParserT__10 {
			{
				p.SetState(247)
				p.Match(SolidityParserT__10)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(248)
				p.Identifier()
			}

		}
		{
			p.SetState(251)
			p.Match(SolidityParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(253)
			p.Match(SolidityParserT__11)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(256)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case SolidityParserT__12:
			{
				p.SetState(254)
				p.Match(SolidityParserT__12)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case SolidityParserT__13, SolidityParserT__24, SolidityParserT__41, SolidityParserT__53, SolidityParserT__95, SolidityParserLeaveKeyword, SolidityParserPayableKeyword, SolidityParserConstructorKeyword, SolidityParserReceiveKeyword, SolidityParserIdentifier:
			{
				p.SetState(255)
				p.Identifier()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		p.SetState(260)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SolidityParserT__10 {
			{
				p.SetState(258)
				p.Match(SolidityParserT__10)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(259)
				p.Identifier()
			}

		}
		{
			p.SetState(262)
			p.Match(SolidityParserT__13)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(263)
			p.ImportPath()
		}
		{
			p.SetState(264)
			p.Match(SolidityParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(266)
			p.Match(SolidityParserT__11)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(267)
			p.Match(SolidityParserT__14)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(268)
			p.ImportDeclaration()
		}
		p.SetState(273)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == SolidityParserT__15 {
			{
				p.SetState(269)
				p.Match(SolidityParserT__15)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(270)
				p.ImportDeclaration()
			}

			p.SetState(275)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(276)
			p.Match(SolidityParserT__16)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(277)
			p.Match(SolidityParserT__13)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(278)
			p.ImportPath()
		}
		{
			p.SetState(279)
			p.Match(SolidityParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImportPathContext is an interface to support dynamic dispatch.
type IImportPathContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	StringLiteralFragment() antlr.TerminalNode

	// IsImportPathContext differentiates from other interfaces.
	IsImportPathContext()
}

type ImportPathContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImportPathContext() *ImportPathContext {
	var p = new(ImportPathContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_importPath
	return p
}

func InitEmptyImportPathContext(p *ImportPathContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_importPath
}

func (*ImportPathContext) IsImportPathContext() {}

func NewImportPathContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportPathContext {
	var p = new(ImportPathContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_importPath

	return p
}

func (s *ImportPathContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportPathContext) StringLiteralFragment() antlr.TerminalNode {
	return s.GetToken(SolidityParserStringLiteralFragment, 0)
}

func (s *ImportPathContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportPathContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportPathContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterImportPath(s)
	}
}

func (s *ImportPathContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitImportPath(s)
	}
}

func (p *SolidityParser) ImportPath() (localctx IImportPathContext) {
	localctx = NewImportPathContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, SolidityParserRULE_importPath)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(283)
		p.Match(SolidityParserStringLiteralFragment)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IContractDefinitionContext is an interface to support dynamic dispatch.
type IContractDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	AllInheritanceSpecifier() []IInheritanceSpecifierContext
	InheritanceSpecifier(i int) IInheritanceSpecifierContext
	AllContractPart() []IContractPartContext
	ContractPart(i int) IContractPartContext

	// IsContractDefinitionContext differentiates from other interfaces.
	IsContractDefinitionContext()
}

type ContractDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyContractDefinitionContext() *ContractDefinitionContext {
	var p = new(ContractDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_contractDefinition
	return p
}

func InitEmptyContractDefinitionContext(p *ContractDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_contractDefinition
}

func (*ContractDefinitionContext) IsContractDefinitionContext() {}

func NewContractDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ContractDefinitionContext {
	var p = new(ContractDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_contractDefinition

	return p
}

func (s *ContractDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *ContractDefinitionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ContractDefinitionContext) AllInheritanceSpecifier() []IInheritanceSpecifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IInheritanceSpecifierContext); ok {
			len++
		}
	}

	tst := make([]IInheritanceSpecifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IInheritanceSpecifierContext); ok {
			tst[i] = t.(IInheritanceSpecifierContext)
			i++
		}
	}

	return tst
}

func (s *ContractDefinitionContext) InheritanceSpecifier(i int) IInheritanceSpecifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInheritanceSpecifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInheritanceSpecifierContext)
}

func (s *ContractDefinitionContext) AllContractPart() []IContractPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IContractPartContext); ok {
			len++
		}
	}

	tst := make([]IContractPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IContractPartContext); ok {
			tst[i] = t.(IContractPartContext)
			i++
		}
	}

	return tst
}

func (s *ContractDefinitionContext) ContractPart(i int) IContractPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IContractPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IContractPartContext)
}

func (s *ContractDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ContractDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ContractDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterContractDefinition(s)
	}
}

func (s *ContractDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitContractDefinition(s)
	}
}

func (p *SolidityParser) ContractDefinition() (localctx IContractDefinitionContext) {
	localctx = NewContractDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, SolidityParserRULE_contractDefinition)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(286)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SolidityParserT__17 {
		{
			p.SetState(285)
			p.Match(SolidityParserT__17)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(288)
		_la = p.GetTokenStream().LA(1)

		if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&3670016) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(289)
		p.Identifier()
	}
	p.SetState(299)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SolidityParserT__21 {
		{
			p.SetState(290)
			p.Match(SolidityParserT__21)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(291)
			p.InheritanceSpecifier()
		}
		p.SetState(296)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == SolidityParserT__15 {
			{
				p.SetState(292)
				p.Match(SolidityParserT__15)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(293)
				p.InheritanceSpecifier()
			}

			p.SetState(298)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(301)
		p.Match(SolidityParserT__14)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(305)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&558451110302466048) != 0) || ((int64((_la-96)) & ^0x3f) == 0 && ((int64(1)<<(_la-96))&8057520253) != 0) {
		{
			p.SetState(302)
			p.ContractPart()
		}

		p.SetState(307)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(308)
		p.Match(SolidityParserT__16)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInheritanceSpecifierContext is an interface to support dynamic dispatch.
type IInheritanceSpecifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UserDefinedTypeName() IUserDefinedTypeNameContext
	ExpressionList() IExpressionListContext

	// IsInheritanceSpecifierContext differentiates from other interfaces.
	IsInheritanceSpecifierContext()
}

type InheritanceSpecifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInheritanceSpecifierContext() *InheritanceSpecifierContext {
	var p = new(InheritanceSpecifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_inheritanceSpecifier
	return p
}

func InitEmptyInheritanceSpecifierContext(p *InheritanceSpecifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_inheritanceSpecifier
}

func (*InheritanceSpecifierContext) IsInheritanceSpecifierContext() {}

func NewInheritanceSpecifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InheritanceSpecifierContext {
	var p = new(InheritanceSpecifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_inheritanceSpecifier

	return p
}

func (s *InheritanceSpecifierContext) GetParser() antlr.Parser { return s.parser }

func (s *InheritanceSpecifierContext) UserDefinedTypeName() IUserDefinedTypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserDefinedTypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserDefinedTypeNameContext)
}

func (s *InheritanceSpecifierContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *InheritanceSpecifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InheritanceSpecifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InheritanceSpecifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterInheritanceSpecifier(s)
	}
}

func (s *InheritanceSpecifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitInheritanceSpecifier(s)
	}
}

func (p *SolidityParser) InheritanceSpecifier() (localctx IInheritanceSpecifierContext) {
	localctx = NewInheritanceSpecifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, SolidityParserRULE_inheritanceSpecifier)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(310)
		p.UserDefinedTypeName()
	}
	p.SetState(316)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SolidityParserT__22 {
		{
			p.SetState(311)
			p.Match(SolidityParserT__22)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(313)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64((_la-5)) & ^0x3f) == 0 && ((int64(1)<<(_la-5))&9078694038950117889) != 0) || ((int64((_la-96)) & ^0x3f) == 0 && ((int64(1)<<(_la-96))&15707933693) != 0) {
			{
				p.SetState(312)
				p.ExpressionList()
			}

		}
		{
			p.SetState(315)
			p.Match(SolidityParserT__23)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IContractPartContext is an interface to support dynamic dispatch.
type IContractPartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	StateVariableDeclaration() IStateVariableDeclarationContext
	UsingForDeclaration() IUsingForDeclarationContext
	StructDefinition() IStructDefinitionContext
	ModifierDefinition() IModifierDefinitionContext
	FunctionDefinition() IFunctionDefinitionContext
	EventDefinition() IEventDefinitionContext
	EnumDefinition() IEnumDefinitionContext
	CustomErrorDefinition() ICustomErrorDefinitionContext

	// IsContractPartContext differentiates from other interfaces.
	IsContractPartContext()
}

type ContractPartContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyContractPartContext() *ContractPartContext {
	var p = new(ContractPartContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_contractPart
	return p
}

func InitEmptyContractPartContext(p *ContractPartContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_contractPart
}

func (*ContractPartContext) IsContractPartContext() {}

func NewContractPartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ContractPartContext {
	var p = new(ContractPartContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_contractPart

	return p
}

func (s *ContractPartContext) GetParser() antlr.Parser { return s.parser }

func (s *ContractPartContext) StateVariableDeclaration() IStateVariableDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStateVariableDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStateVariableDeclarationContext)
}

func (s *ContractPartContext) UsingForDeclaration() IUsingForDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUsingForDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUsingForDeclarationContext)
}

func (s *ContractPartContext) StructDefinition() IStructDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStructDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStructDefinitionContext)
}

func (s *ContractPartContext) ModifierDefinition() IModifierDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifierDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifierDefinitionContext)
}

func (s *ContractPartContext) FunctionDefinition() IFunctionDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionDefinitionContext)
}

func (s *ContractPartContext) EventDefinition() IEventDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEventDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEventDefinitionContext)
}

func (s *ContractPartContext) EnumDefinition() IEnumDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumDefinitionContext)
}

func (s *ContractPartContext) CustomErrorDefinition() ICustomErrorDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICustomErrorDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICustomErrorDefinitionContext)
}

func (s *ContractPartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ContractPartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ContractPartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterContractPart(s)
	}
}

func (s *ContractPartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitContractPart(s)
	}
}

func (p *SolidityParser) ContractPart() (localctx IContractPartContext) {
	localctx = NewContractPartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, SolidityParserRULE_contractPart)
	p.SetState(326)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 20, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(318)
			p.StateVariableDeclaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(319)
			p.UsingForDeclaration()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(320)
			p.StructDefinition()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(321)
			p.ModifierDefinition()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(322)
			p.FunctionDefinition()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(323)
			p.EventDefinition()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(324)
			p.EnumDefinition()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(325)
			p.CustomErrorDefinition()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStateVariableDeclarationContext is an interface to support dynamic dispatch.
type IStateVariableDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypeName() ITypeNameContext
	Identifier() IIdentifierContext
	AllPublicKeyword() []antlr.TerminalNode
	PublicKeyword(i int) antlr.TerminalNode
	AllInternalKeyword() []antlr.TerminalNode
	InternalKeyword(i int) antlr.TerminalNode
	AllPrivateKeyword() []antlr.TerminalNode
	PrivateKeyword(i int) antlr.TerminalNode
	AllConstantKeyword() []antlr.TerminalNode
	ConstantKeyword(i int) antlr.TerminalNode
	AllImmutableKeyword() []antlr.TerminalNode
	ImmutableKeyword(i int) antlr.TerminalNode
	AllOverrideSpecifier() []IOverrideSpecifierContext
	OverrideSpecifier(i int) IOverrideSpecifierContext
	Expression() IExpressionContext

	// IsStateVariableDeclarationContext differentiates from other interfaces.
	IsStateVariableDeclarationContext()
}

type StateVariableDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStateVariableDeclarationContext() *StateVariableDeclarationContext {
	var p = new(StateVariableDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_stateVariableDeclaration
	return p
}

func InitEmptyStateVariableDeclarationContext(p *StateVariableDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_stateVariableDeclaration
}

func (*StateVariableDeclarationContext) IsStateVariableDeclarationContext() {}

func NewStateVariableDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StateVariableDeclarationContext {
	var p = new(StateVariableDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_stateVariableDeclaration

	return p
}

func (s *StateVariableDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *StateVariableDeclarationContext) TypeName() ITypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *StateVariableDeclarationContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *StateVariableDeclarationContext) AllPublicKeyword() []antlr.TerminalNode {
	return s.GetTokens(SolidityParserPublicKeyword)
}

func (s *StateVariableDeclarationContext) PublicKeyword(i int) antlr.TerminalNode {
	return s.GetToken(SolidityParserPublicKeyword, i)
}

func (s *StateVariableDeclarationContext) AllInternalKeyword() []antlr.TerminalNode {
	return s.GetTokens(SolidityParserInternalKeyword)
}

func (s *StateVariableDeclarationContext) InternalKeyword(i int) antlr.TerminalNode {
	return s.GetToken(SolidityParserInternalKeyword, i)
}

func (s *StateVariableDeclarationContext) AllPrivateKeyword() []antlr.TerminalNode {
	return s.GetTokens(SolidityParserPrivateKeyword)
}

func (s *StateVariableDeclarationContext) PrivateKeyword(i int) antlr.TerminalNode {
	return s.GetToken(SolidityParserPrivateKeyword, i)
}

func (s *StateVariableDeclarationContext) AllConstantKeyword() []antlr.TerminalNode {
	return s.GetTokens(SolidityParserConstantKeyword)
}

func (s *StateVariableDeclarationContext) ConstantKeyword(i int) antlr.TerminalNode {
	return s.GetToken(SolidityParserConstantKeyword, i)
}

func (s *StateVariableDeclarationContext) AllImmutableKeyword() []antlr.TerminalNode {
	return s.GetTokens(SolidityParserImmutableKeyword)
}

func (s *StateVariableDeclarationContext) ImmutableKeyword(i int) antlr.TerminalNode {
	return s.GetToken(SolidityParserImmutableKeyword, i)
}

func (s *StateVariableDeclarationContext) AllOverrideSpecifier() []IOverrideSpecifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IOverrideSpecifierContext); ok {
			len++
		}
	}

	tst := make([]IOverrideSpecifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IOverrideSpecifierContext); ok {
			tst[i] = t.(IOverrideSpecifierContext)
			i++
		}
	}

	return tst
}

func (s *StateVariableDeclarationContext) OverrideSpecifier(i int) IOverrideSpecifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOverrideSpecifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOverrideSpecifierContext)
}

func (s *StateVariableDeclarationContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *StateVariableDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StateVariableDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StateVariableDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterStateVariableDeclaration(s)
	}
}

func (s *StateVariableDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitStateVariableDeclaration(s)
	}
}

func (p *SolidityParser) StateVariableDeclaration() (localctx IStateVariableDeclarationContext) {
	localctx = NewStateVariableDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, SolidityParserRULE_stateVariableDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(328)
		p.typeName(0)
	}
	p.SetState(337)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for (int64((_la-97)) & ^0x3f) == 0 && ((int64(1)<<(_la-97))&13680641) != 0 {
		p.SetState(335)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case SolidityParserPublicKeyword:
			{
				p.SetState(329)
				p.Match(SolidityParserPublicKeyword)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case SolidityParserInternalKeyword:
			{
				p.SetState(330)
				p.Match(SolidityParserInternalKeyword)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case SolidityParserPrivateKeyword:
			{
				p.SetState(331)
				p.Match(SolidityParserPrivateKeyword)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case SolidityParserConstantKeyword:
			{
				p.SetState(332)
				p.Match(SolidityParserConstantKeyword)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case SolidityParserImmutableKeyword:
			{
				p.SetState(333)
				p.Match(SolidityParserImmutableKeyword)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case SolidityParserT__96:
			{
				p.SetState(334)
				p.OverrideSpecifier()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(339)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(340)
		p.Identifier()
	}
	p.SetState(343)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SolidityParserT__9 {
		{
			p.SetState(341)
			p.Match(SolidityParserT__9)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(342)
			p.expression(0)
		}

	}
	{
		p.SetState(345)
		p.Match(SolidityParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFileLevelConstantContext is an interface to support dynamic dispatch.
type IFileLevelConstantContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypeName() ITypeNameContext
	ConstantKeyword() antlr.TerminalNode
	Identifier() IIdentifierContext
	Expression() IExpressionContext

	// IsFileLevelConstantContext differentiates from other interfaces.
	IsFileLevelConstantContext()
}

type FileLevelConstantContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFileLevelConstantContext() *FileLevelConstantContext {
	var p = new(FileLevelConstantContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_fileLevelConstant
	return p
}

func InitEmptyFileLevelConstantContext(p *FileLevelConstantContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_fileLevelConstant
}

func (*FileLevelConstantContext) IsFileLevelConstantContext() {}

func NewFileLevelConstantContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FileLevelConstantContext {
	var p = new(FileLevelConstantContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_fileLevelConstant

	return p
}

func (s *FileLevelConstantContext) GetParser() antlr.Parser { return s.parser }

func (s *FileLevelConstantContext) TypeName() ITypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *FileLevelConstantContext) ConstantKeyword() antlr.TerminalNode {
	return s.GetToken(SolidityParserConstantKeyword, 0)
}

func (s *FileLevelConstantContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *FileLevelConstantContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *FileLevelConstantContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FileLevelConstantContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FileLevelConstantContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterFileLevelConstant(s)
	}
}

func (s *FileLevelConstantContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitFileLevelConstant(s)
	}
}

func (p *SolidityParser) FileLevelConstant() (localctx IFileLevelConstantContext) {
	localctx = NewFileLevelConstantContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, SolidityParserRULE_fileLevelConstant)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(347)
		p.typeName(0)
	}
	{
		p.SetState(348)
		p.Match(SolidityParserConstantKeyword)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(349)
		p.Identifier()
	}
	{
		p.SetState(350)
		p.Match(SolidityParserT__9)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(351)
		p.expression(0)
	}
	{
		p.SetState(352)
		p.Match(SolidityParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICustomErrorDefinitionContext is an interface to support dynamic dispatch.
type ICustomErrorDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	ParameterList() IParameterListContext

	// IsCustomErrorDefinitionContext differentiates from other interfaces.
	IsCustomErrorDefinitionContext()
}

type CustomErrorDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCustomErrorDefinitionContext() *CustomErrorDefinitionContext {
	var p = new(CustomErrorDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_customErrorDefinition
	return p
}

func InitEmptyCustomErrorDefinitionContext(p *CustomErrorDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_customErrorDefinition
}

func (*CustomErrorDefinitionContext) IsCustomErrorDefinitionContext() {}

func NewCustomErrorDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CustomErrorDefinitionContext {
	var p = new(CustomErrorDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_customErrorDefinition

	return p
}

func (s *CustomErrorDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *CustomErrorDefinitionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CustomErrorDefinitionContext) ParameterList() IParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterListContext)
}

func (s *CustomErrorDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CustomErrorDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CustomErrorDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterCustomErrorDefinition(s)
	}
}

func (s *CustomErrorDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitCustomErrorDefinition(s)
	}
}

func (p *SolidityParser) CustomErrorDefinition() (localctx ICustomErrorDefinitionContext) {
	localctx = NewCustomErrorDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, SolidityParserRULE_customErrorDefinition)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(354)
		p.Match(SolidityParserT__24)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(355)
		p.Identifier()
	}
	{
		p.SetState(356)
		p.ParameterList()
	}
	{
		p.SetState(357)
		p.Match(SolidityParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUsingForDeclarationContext is an interface to support dynamic dispatch.
type IUsingForDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	TypeName() ITypeNameContext

	// IsUsingForDeclarationContext differentiates from other interfaces.
	IsUsingForDeclarationContext()
}

type UsingForDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUsingForDeclarationContext() *UsingForDeclarationContext {
	var p = new(UsingForDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_usingForDeclaration
	return p
}

func InitEmptyUsingForDeclarationContext(p *UsingForDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_usingForDeclaration
}

func (*UsingForDeclarationContext) IsUsingForDeclarationContext() {}

func NewUsingForDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UsingForDeclarationContext {
	var p = new(UsingForDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_usingForDeclaration

	return p
}

func (s *UsingForDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *UsingForDeclarationContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *UsingForDeclarationContext) TypeName() ITypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *UsingForDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UsingForDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UsingForDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterUsingForDeclaration(s)
	}
}

func (s *UsingForDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitUsingForDeclaration(s)
	}
}

func (p *SolidityParser) UsingForDeclaration() (localctx IUsingForDeclarationContext) {
	localctx = NewUsingForDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, SolidityParserRULE_usingForDeclaration)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(359)
		p.Match(SolidityParserT__25)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(360)
		p.Identifier()
	}
	{
		p.SetState(361)
		p.Match(SolidityParserT__26)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(364)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SolidityParserT__12:
		{
			p.SetState(362)
			p.Match(SolidityParserT__12)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SolidityParserT__13, SolidityParserT__24, SolidityParserT__29, SolidityParserT__35, SolidityParserT__37, SolidityParserT__41, SolidityParserT__53, SolidityParserT__54, SolidityParserT__55, SolidityParserT__56, SolidityParserT__57, SolidityParserT__95, SolidityParserInt, SolidityParserUint, SolidityParserByte, SolidityParserFixed, SolidityParserUfixed, SolidityParserLeaveKeyword, SolidityParserPayableKeyword, SolidityParserConstructorKeyword, SolidityParserReceiveKeyword, SolidityParserIdentifier:
		{
			p.SetState(363)
			p.typeName(0)
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	{
		p.SetState(366)
		p.Match(SolidityParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStructDefinitionContext is an interface to support dynamic dispatch.
type IStructDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	AllVariableDeclaration() []IVariableDeclarationContext
	VariableDeclaration(i int) IVariableDeclarationContext

	// IsStructDefinitionContext differentiates from other interfaces.
	IsStructDefinitionContext()
}

type StructDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStructDefinitionContext() *StructDefinitionContext {
	var p = new(StructDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_structDefinition
	return p
}

func InitEmptyStructDefinitionContext(p *StructDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_structDefinition
}

func (*StructDefinitionContext) IsStructDefinitionContext() {}

func NewStructDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StructDefinitionContext {
	var p = new(StructDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_structDefinition

	return p
}

func (s *StructDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *StructDefinitionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *StructDefinitionContext) AllVariableDeclaration() []IVariableDeclarationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVariableDeclarationContext); ok {
			len++
		}
	}

	tst := make([]IVariableDeclarationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVariableDeclarationContext); ok {
			tst[i] = t.(IVariableDeclarationContext)
			i++
		}
	}

	return tst
}

func (s *StructDefinitionContext) VariableDeclaration(i int) IVariableDeclarationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDeclarationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDeclarationContext)
}

func (s *StructDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StructDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StructDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterStructDefinition(s)
	}
}

func (s *StructDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitStructDefinition(s)
	}
}

func (p *SolidityParser) StructDefinition() (localctx IStructDefinitionContext) {
	localctx = NewStructDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, SolidityParserRULE_structDefinition)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(368)
		p.Match(SolidityParserT__27)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(369)
		p.Identifier()
	}
	{
		p.SetState(370)
		p.Match(SolidityParserT__14)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(381)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&558451096545148928) != 0) || ((int64((_la-96)) & ^0x3f) == 0 && ((int64(1)<<(_la-96))&6983778429) != 0) {
		{
			p.SetState(371)
			p.VariableDeclaration()
		}
		{
			p.SetState(372)
			p.Match(SolidityParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(378)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&558451096545148928) != 0) || ((int64((_la-96)) & ^0x3f) == 0 && ((int64(1)<<(_la-96))&6983778429) != 0) {
			{
				p.SetState(373)
				p.VariableDeclaration()
			}
			{
				p.SetState(374)
				p.Match(SolidityParserT__1)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(380)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(383)
		p.Match(SolidityParserT__16)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IModifierDefinitionContext is an interface to support dynamic dispatch.
type IModifierDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	Block() IBlockContext
	ParameterList() IParameterListContext
	AllVirtualKeyword() []antlr.TerminalNode
	VirtualKeyword(i int) antlr.TerminalNode
	AllOverrideSpecifier() []IOverrideSpecifierContext
	OverrideSpecifier(i int) IOverrideSpecifierContext

	// IsModifierDefinitionContext differentiates from other interfaces.
	IsModifierDefinitionContext()
}

type ModifierDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModifierDefinitionContext() *ModifierDefinitionContext {
	var p = new(ModifierDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_modifierDefinition
	return p
}

func InitEmptyModifierDefinitionContext(p *ModifierDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_modifierDefinition
}

func (*ModifierDefinitionContext) IsModifierDefinitionContext() {}

func NewModifierDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModifierDefinitionContext {
	var p = new(ModifierDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_modifierDefinition

	return p
}

func (s *ModifierDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *ModifierDefinitionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ModifierDefinitionContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *ModifierDefinitionContext) ParameterList() IParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterListContext)
}

func (s *ModifierDefinitionContext) AllVirtualKeyword() []antlr.TerminalNode {
	return s.GetTokens(SolidityParserVirtualKeyword)
}

func (s *ModifierDefinitionContext) VirtualKeyword(i int) antlr.TerminalNode {
	return s.GetToken(SolidityParserVirtualKeyword, i)
}

func (s *ModifierDefinitionContext) AllOverrideSpecifier() []IOverrideSpecifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IOverrideSpecifierContext); ok {
			len++
		}
	}

	tst := make([]IOverrideSpecifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IOverrideSpecifierContext); ok {
			tst[i] = t.(IOverrideSpecifierContext)
			i++
		}
	}

	return tst
}

func (s *ModifierDefinitionContext) OverrideSpecifier(i int) IOverrideSpecifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOverrideSpecifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOverrideSpecifierContext)
}

func (s *ModifierDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModifierDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModifierDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterModifierDefinition(s)
	}
}

func (s *ModifierDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitModifierDefinition(s)
	}
}

func (p *SolidityParser) ModifierDefinition() (localctx IModifierDefinitionContext) {
	localctx = NewModifierDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, SolidityParserRULE_modifierDefinition)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(385)
		p.Match(SolidityParserT__28)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(386)
		p.Identifier()
	}
	p.SetState(388)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SolidityParserT__22 {
		{
			p.SetState(387)
			p.ParameterList()
		}

	}
	p.SetState(394)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SolidityParserT__96 || _la == SolidityParserVirtualKeyword {
		p.SetState(392)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case SolidityParserVirtualKeyword:
			{
				p.SetState(390)
				p.Match(SolidityParserVirtualKeyword)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case SolidityParserT__96:
			{
				p.SetState(391)
				p.OverrideSpecifier()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(396)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(399)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SolidityParserT__1:
		{
			p.SetState(397)
			p.Match(SolidityParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SolidityParserT__14:
		{
			p.SetState(398)
			p.Block()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IModifierInvocationContext is an interface to support dynamic dispatch.
type IModifierInvocationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	ExpressionList() IExpressionListContext

	// IsModifierInvocationContext differentiates from other interfaces.
	IsModifierInvocationContext()
}

type ModifierInvocationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModifierInvocationContext() *ModifierInvocationContext {
	var p = new(ModifierInvocationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_modifierInvocation
	return p
}

func InitEmptyModifierInvocationContext(p *ModifierInvocationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_modifierInvocation
}

func (*ModifierInvocationContext) IsModifierInvocationContext() {}

func NewModifierInvocationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModifierInvocationContext {
	var p = new(ModifierInvocationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_modifierInvocation

	return p
}

func (s *ModifierInvocationContext) GetParser() antlr.Parser { return s.parser }

func (s *ModifierInvocationContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ModifierInvocationContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *ModifierInvocationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModifierInvocationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModifierInvocationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterModifierInvocation(s)
	}
}

func (s *ModifierInvocationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitModifierInvocation(s)
	}
}

func (p *SolidityParser) ModifierInvocation() (localctx IModifierInvocationContext) {
	localctx = NewModifierInvocationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, SolidityParserRULE_modifierInvocation)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(401)
		p.Identifier()
	}
	p.SetState(407)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SolidityParserT__22 {
		{
			p.SetState(402)
			p.Match(SolidityParserT__22)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(404)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64((_la-5)) & ^0x3f) == 0 && ((int64(1)<<(_la-5))&9078694038950117889) != 0) || ((int64((_la-96)) & ^0x3f) == 0 && ((int64(1)<<(_la-96))&15707933693) != 0) {
			{
				p.SetState(403)
				p.ExpressionList()
			}

		}
		{
			p.SetState(406)
			p.Match(SolidityParserT__23)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionDefinitionContext is an interface to support dynamic dispatch.
type IFunctionDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FunctionDescriptor() IFunctionDescriptorContext
	ParameterList() IParameterListContext
	ModifierList() IModifierListContext
	Block() IBlockContext
	ReturnParameters() IReturnParametersContext

	// IsFunctionDefinitionContext differentiates from other interfaces.
	IsFunctionDefinitionContext()
}

type FunctionDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionDefinitionContext() *FunctionDefinitionContext {
	var p = new(FunctionDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_functionDefinition
	return p
}

func InitEmptyFunctionDefinitionContext(p *FunctionDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_functionDefinition
}

func (*FunctionDefinitionContext) IsFunctionDefinitionContext() {}

func NewFunctionDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionDefinitionContext {
	var p = new(FunctionDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_functionDefinition

	return p
}

func (s *FunctionDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionDefinitionContext) FunctionDescriptor() IFunctionDescriptorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionDescriptorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionDescriptorContext)
}

func (s *FunctionDefinitionContext) ParameterList() IParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterListContext)
}

func (s *FunctionDefinitionContext) ModifierList() IModifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifierListContext)
}

func (s *FunctionDefinitionContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *FunctionDefinitionContext) ReturnParameters() IReturnParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReturnParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReturnParametersContext)
}

func (s *FunctionDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterFunctionDefinition(s)
	}
}

func (s *FunctionDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitFunctionDefinition(s)
	}
}

func (p *SolidityParser) FunctionDefinition() (localctx IFunctionDefinitionContext) {
	localctx = NewFunctionDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, SolidityParserRULE_functionDefinition)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(409)
		p.FunctionDescriptor()
	}
	{
		p.SetState(410)
		p.ParameterList()
	}
	{
		p.SetState(411)
		p.ModifierList()
	}
	p.SetState(413)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SolidityParserT__30 {
		{
			p.SetState(412)
			p.ReturnParameters()
		}

	}
	p.SetState(417)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SolidityParserT__1:
		{
			p.SetState(415)
			p.Match(SolidityParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SolidityParserT__14:
		{
			p.SetState(416)
			p.Block()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionDescriptorContext is an interface to support dynamic dispatch.
type IFunctionDescriptorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	ConstructorKeyword() antlr.TerminalNode
	FallbackKeyword() antlr.TerminalNode
	ReceiveKeyword() antlr.TerminalNode

	// IsFunctionDescriptorContext differentiates from other interfaces.
	IsFunctionDescriptorContext()
}

type FunctionDescriptorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionDescriptorContext() *FunctionDescriptorContext {
	var p = new(FunctionDescriptorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_functionDescriptor
	return p
}

func InitEmptyFunctionDescriptorContext(p *FunctionDescriptorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_functionDescriptor
}

func (*FunctionDescriptorContext) IsFunctionDescriptorContext() {}

func NewFunctionDescriptorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionDescriptorContext {
	var p = new(FunctionDescriptorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_functionDescriptor

	return p
}

func (s *FunctionDescriptorContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionDescriptorContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *FunctionDescriptorContext) ConstructorKeyword() antlr.TerminalNode {
	return s.GetToken(SolidityParserConstructorKeyword, 0)
}

func (s *FunctionDescriptorContext) FallbackKeyword() antlr.TerminalNode {
	return s.GetToken(SolidityParserFallbackKeyword, 0)
}

func (s *FunctionDescriptorContext) ReceiveKeyword() antlr.TerminalNode {
	return s.GetToken(SolidityParserReceiveKeyword, 0)
}

func (s *FunctionDescriptorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionDescriptorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionDescriptorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterFunctionDescriptor(s)
	}
}

func (s *FunctionDescriptorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitFunctionDescriptor(s)
	}
}

func (p *SolidityParser) FunctionDescriptor() (localctx IFunctionDescriptorContext) {
	localctx = NewFunctionDescriptorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, SolidityParserRULE_functionDescriptor)
	var _la int

	p.SetState(426)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SolidityParserT__29:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(419)
			p.Match(SolidityParserT__29)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(421)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&18018796589563904) != 0) || ((int64((_la-96)) & ^0x3f) == 0 && ((int64(1)<<(_la-96))&6983778305) != 0) {
			{
				p.SetState(420)
				p.Identifier()
			}

		}

	case SolidityParserConstructorKeyword:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(423)
			p.Match(SolidityParserConstructorKeyword)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SolidityParserFallbackKeyword:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(424)
			p.Match(SolidityParserFallbackKeyword)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SolidityParserReceiveKeyword:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(425)
			p.Match(SolidityParserReceiveKeyword)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReturnParametersContext is an interface to support dynamic dispatch.
type IReturnParametersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ParameterList() IParameterListContext

	// IsReturnParametersContext differentiates from other interfaces.
	IsReturnParametersContext()
}

type ReturnParametersContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReturnParametersContext() *ReturnParametersContext {
	var p = new(ReturnParametersContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_returnParameters
	return p
}

func InitEmptyReturnParametersContext(p *ReturnParametersContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_returnParameters
}

func (*ReturnParametersContext) IsReturnParametersContext() {}

func NewReturnParametersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReturnParametersContext {
	var p = new(ReturnParametersContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_returnParameters

	return p
}

func (s *ReturnParametersContext) GetParser() antlr.Parser { return s.parser }

func (s *ReturnParametersContext) ParameterList() IParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterListContext)
}

func (s *ReturnParametersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReturnParametersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReturnParametersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterReturnParameters(s)
	}
}

func (s *ReturnParametersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitReturnParameters(s)
	}
}

func (p *SolidityParser) ReturnParameters() (localctx IReturnParametersContext) {
	localctx = NewReturnParametersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, SolidityParserRULE_returnParameters)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(428)
		p.Match(SolidityParserT__30)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(429)
		p.ParameterList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IModifierListContext is an interface to support dynamic dispatch.
type IModifierListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExternalKeyword() []antlr.TerminalNode
	ExternalKeyword(i int) antlr.TerminalNode
	AllPublicKeyword() []antlr.TerminalNode
	PublicKeyword(i int) antlr.TerminalNode
	AllInternalKeyword() []antlr.TerminalNode
	InternalKeyword(i int) antlr.TerminalNode
	AllPrivateKeyword() []antlr.TerminalNode
	PrivateKeyword(i int) antlr.TerminalNode
	AllVirtualKeyword() []antlr.TerminalNode
	VirtualKeyword(i int) antlr.TerminalNode
	AllStateMutability() []IStateMutabilityContext
	StateMutability(i int) IStateMutabilityContext
	AllModifierInvocation() []IModifierInvocationContext
	ModifierInvocation(i int) IModifierInvocationContext
	AllOverrideSpecifier() []IOverrideSpecifierContext
	OverrideSpecifier(i int) IOverrideSpecifierContext

	// IsModifierListContext differentiates from other interfaces.
	IsModifierListContext()
}

type ModifierListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModifierListContext() *ModifierListContext {
	var p = new(ModifierListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_modifierList
	return p
}

func InitEmptyModifierListContext(p *ModifierListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_modifierList
}

func (*ModifierListContext) IsModifierListContext() {}

func NewModifierListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModifierListContext {
	var p = new(ModifierListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_modifierList

	return p
}

func (s *ModifierListContext) GetParser() antlr.Parser { return s.parser }

func (s *ModifierListContext) AllExternalKeyword() []antlr.TerminalNode {
	return s.GetTokens(SolidityParserExternalKeyword)
}

func (s *ModifierListContext) ExternalKeyword(i int) antlr.TerminalNode {
	return s.GetToken(SolidityParserExternalKeyword, i)
}

func (s *ModifierListContext) AllPublicKeyword() []antlr.TerminalNode {
	return s.GetTokens(SolidityParserPublicKeyword)
}

func (s *ModifierListContext) PublicKeyword(i int) antlr.TerminalNode {
	return s.GetToken(SolidityParserPublicKeyword, i)
}

func (s *ModifierListContext) AllInternalKeyword() []antlr.TerminalNode {
	return s.GetTokens(SolidityParserInternalKeyword)
}

func (s *ModifierListContext) InternalKeyword(i int) antlr.TerminalNode {
	return s.GetToken(SolidityParserInternalKeyword, i)
}

func (s *ModifierListContext) AllPrivateKeyword() []antlr.TerminalNode {
	return s.GetTokens(SolidityParserPrivateKeyword)
}

func (s *ModifierListContext) PrivateKeyword(i int) antlr.TerminalNode {
	return s.GetToken(SolidityParserPrivateKeyword, i)
}

func (s *ModifierListContext) AllVirtualKeyword() []antlr.TerminalNode {
	return s.GetTokens(SolidityParserVirtualKeyword)
}

func (s *ModifierListContext) VirtualKeyword(i int) antlr.TerminalNode {
	return s.GetToken(SolidityParserVirtualKeyword, i)
}

func (s *ModifierListContext) AllStateMutability() []IStateMutabilityContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStateMutabilityContext); ok {
			len++
		}
	}

	tst := make([]IStateMutabilityContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStateMutabilityContext); ok {
			tst[i] = t.(IStateMutabilityContext)
			i++
		}
	}

	return tst
}

func (s *ModifierListContext) StateMutability(i int) IStateMutabilityContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStateMutabilityContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStateMutabilityContext)
}

func (s *ModifierListContext) AllModifierInvocation() []IModifierInvocationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IModifierInvocationContext); ok {
			len++
		}
	}

	tst := make([]IModifierInvocationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IModifierInvocationContext); ok {
			tst[i] = t.(IModifierInvocationContext)
			i++
		}
	}

	return tst
}

func (s *ModifierListContext) ModifierInvocation(i int) IModifierInvocationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifierInvocationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifierInvocationContext)
}

func (s *ModifierListContext) AllOverrideSpecifier() []IOverrideSpecifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IOverrideSpecifierContext); ok {
			len++
		}
	}

	tst := make([]IOverrideSpecifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IOverrideSpecifierContext); ok {
			tst[i] = t.(IOverrideSpecifierContext)
			i++
		}
	}

	return tst
}

func (s *ModifierListContext) OverrideSpecifier(i int) IOverrideSpecifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOverrideSpecifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOverrideSpecifierContext)
}

func (s *ModifierListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModifierListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModifierListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterModifierList(s)
	}
}

func (s *ModifierListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitModifierList(s)
	}
}

func (p *SolidityParser) ModifierList() (localctx IModifierListContext) {
	localctx = NewModifierListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, SolidityParserRULE_modifierList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(441)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&18018796589563904) != 0) || ((int64((_la-96)) & ^0x3f) == 0 && ((int64(1)<<(_la-96))&7380697091) != 0) {
		p.SetState(439)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 37, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(431)
				p.Match(SolidityParserExternalKeyword)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 2:
			{
				p.SetState(432)
				p.Match(SolidityParserPublicKeyword)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 3:
			{
				p.SetState(433)
				p.Match(SolidityParserInternalKeyword)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 4:
			{
				p.SetState(434)
				p.Match(SolidityParserPrivateKeyword)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 5:
			{
				p.SetState(435)
				p.Match(SolidityParserVirtualKeyword)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 6:
			{
				p.SetState(436)
				p.StateMutability()
			}

		case 7:
			{
				p.SetState(437)
				p.ModifierInvocation()
			}

		case 8:
			{
				p.SetState(438)
				p.OverrideSpecifier()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

		p.SetState(443)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEventDefinitionContext is an interface to support dynamic dispatch.
type IEventDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	EventParameterList() IEventParameterListContext
	AnonymousKeyword() antlr.TerminalNode

	// IsEventDefinitionContext differentiates from other interfaces.
	IsEventDefinitionContext()
}

type EventDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEventDefinitionContext() *EventDefinitionContext {
	var p = new(EventDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_eventDefinition
	return p
}

func InitEmptyEventDefinitionContext(p *EventDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_eventDefinition
}

func (*EventDefinitionContext) IsEventDefinitionContext() {}

func NewEventDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EventDefinitionContext {
	var p = new(EventDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_eventDefinition

	return p
}

func (s *EventDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *EventDefinitionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *EventDefinitionContext) EventParameterList() IEventParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEventParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEventParameterListContext)
}

func (s *EventDefinitionContext) AnonymousKeyword() antlr.TerminalNode {
	return s.GetToken(SolidityParserAnonymousKeyword, 0)
}

func (s *EventDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EventDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EventDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterEventDefinition(s)
	}
}

func (s *EventDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitEventDefinition(s)
	}
}

func (p *SolidityParser) EventDefinition() (localctx IEventDefinitionContext) {
	localctx = NewEventDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, SolidityParserRULE_eventDefinition)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(444)
		p.Match(SolidityParserT__31)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(445)
		p.Identifier()
	}
	{
		p.SetState(446)
		p.EventParameterList()
	}
	p.SetState(448)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SolidityParserAnonymousKeyword {
		{
			p.SetState(447)
			p.Match(SolidityParserAnonymousKeyword)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(450)
		p.Match(SolidityParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEnumValueContext is an interface to support dynamic dispatch.
type IEnumValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext

	// IsEnumValueContext differentiates from other interfaces.
	IsEnumValueContext()
}

type EnumValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumValueContext() *EnumValueContext {
	var p = new(EnumValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_enumValue
	return p
}

func InitEmptyEnumValueContext(p *EnumValueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_enumValue
}

func (*EnumValueContext) IsEnumValueContext() {}

func NewEnumValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumValueContext {
	var p = new(EnumValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_enumValue

	return p
}

func (s *EnumValueContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumValueContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *EnumValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterEnumValue(s)
	}
}

func (s *EnumValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitEnumValue(s)
	}
}

func (p *SolidityParser) EnumValue() (localctx IEnumValueContext) {
	localctx = NewEnumValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, SolidityParserRULE_enumValue)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(452)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEnumDefinitionContext is an interface to support dynamic dispatch.
type IEnumDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	AllEnumValue() []IEnumValueContext
	EnumValue(i int) IEnumValueContext

	// IsEnumDefinitionContext differentiates from other interfaces.
	IsEnumDefinitionContext()
}

type EnumDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumDefinitionContext() *EnumDefinitionContext {
	var p = new(EnumDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_enumDefinition
	return p
}

func InitEmptyEnumDefinitionContext(p *EnumDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_enumDefinition
}

func (*EnumDefinitionContext) IsEnumDefinitionContext() {}

func NewEnumDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumDefinitionContext {
	var p = new(EnumDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_enumDefinition

	return p
}

func (s *EnumDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumDefinitionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *EnumDefinitionContext) AllEnumValue() []IEnumValueContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEnumValueContext); ok {
			len++
		}
	}

	tst := make([]IEnumValueContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEnumValueContext); ok {
			tst[i] = t.(IEnumValueContext)
			i++
		}
	}

	return tst
}

func (s *EnumDefinitionContext) EnumValue(i int) IEnumValueContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumValueContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumValueContext)
}

func (s *EnumDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterEnumDefinition(s)
	}
}

func (s *EnumDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitEnumDefinition(s)
	}
}

func (p *SolidityParser) EnumDefinition() (localctx IEnumDefinitionContext) {
	localctx = NewEnumDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, SolidityParserRULE_enumDefinition)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(454)
		p.Match(SolidityParserT__32)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(455)
		p.Identifier()
	}
	{
		p.SetState(456)
		p.Match(SolidityParserT__14)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(458)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&18018796589563904) != 0) || ((int64((_la-96)) & ^0x3f) == 0 && ((int64(1)<<(_la-96))&6983778305) != 0) {
		{
			p.SetState(457)
			p.EnumValue()
		}

	}
	p.SetState(464)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SolidityParserT__15 {
		{
			p.SetState(460)
			p.Match(SolidityParserT__15)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(461)
			p.EnumValue()
		}

		p.SetState(466)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(467)
		p.Match(SolidityParserT__16)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IParameterListContext is an interface to support dynamic dispatch.
type IParameterListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllParameter() []IParameterContext
	Parameter(i int) IParameterContext

	// IsParameterListContext differentiates from other interfaces.
	IsParameterListContext()
}

type ParameterListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameterListContext() *ParameterListContext {
	var p = new(ParameterListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_parameterList
	return p
}

func InitEmptyParameterListContext(p *ParameterListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_parameterList
}

func (*ParameterListContext) IsParameterListContext() {}

func NewParameterListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParameterListContext {
	var p = new(ParameterListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_parameterList

	return p
}

func (s *ParameterListContext) GetParser() antlr.Parser { return s.parser }

func (s *ParameterListContext) AllParameter() []IParameterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IParameterContext); ok {
			len++
		}
	}

	tst := make([]IParameterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IParameterContext); ok {
			tst[i] = t.(IParameterContext)
			i++
		}
	}

	return tst
}

func (s *ParameterListContext) Parameter(i int) IParameterContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterContext)
}

func (s *ParameterListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParameterListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParameterListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterParameterList(s)
	}
}

func (s *ParameterListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitParameterList(s)
	}
}

func (p *SolidityParser) ParameterList() (localctx IParameterListContext) {
	localctx = NewParameterListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, SolidityParserRULE_parameterList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(469)
		p.Match(SolidityParserT__22)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(478)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&558451096545148928) != 0) || ((int64((_la-96)) & ^0x3f) == 0 && ((int64(1)<<(_la-96))&6983778429) != 0) {
		{
			p.SetState(470)
			p.Parameter()
		}
		p.SetState(475)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == SolidityParserT__15 {
			{
				p.SetState(471)
				p.Match(SolidityParserT__15)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(472)
				p.Parameter()
			}

			p.SetState(477)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(480)
		p.Match(SolidityParserT__23)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IParameterContext is an interface to support dynamic dispatch.
type IParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypeName() ITypeNameContext
	StorageLocation() IStorageLocationContext
	Identifier() IIdentifierContext

	// IsParameterContext differentiates from other interfaces.
	IsParameterContext()
}

type ParameterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameterContext() *ParameterContext {
	var p = new(ParameterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_parameter
	return p
}

func InitEmptyParameterContext(p *ParameterContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_parameter
}

func (*ParameterContext) IsParameterContext() {}

func NewParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParameterContext {
	var p = new(ParameterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_parameter

	return p
}

func (s *ParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *ParameterContext) TypeName() ITypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *ParameterContext) StorageLocation() IStorageLocationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStorageLocationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStorageLocationContext)
}

func (s *ParameterContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterParameter(s)
	}
}

func (s *ParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitParameter(s)
	}
}

func (p *SolidityParser) Parameter() (localctx IParameterContext) {
	localctx = NewParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, SolidityParserRULE_parameter)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(482)
		p.typeName(0)
	}
	p.SetState(484)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 44, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(483)
			p.StorageLocation()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(487)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&18018796589563904) != 0) || ((int64((_la-96)) & ^0x3f) == 0 && ((int64(1)<<(_la-96))&6983778305) != 0) {
		{
			p.SetState(486)
			p.Identifier()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEventParameterListContext is an interface to support dynamic dispatch.
type IEventParameterListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllEventParameter() []IEventParameterContext
	EventParameter(i int) IEventParameterContext

	// IsEventParameterListContext differentiates from other interfaces.
	IsEventParameterListContext()
}

type EventParameterListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEventParameterListContext() *EventParameterListContext {
	var p = new(EventParameterListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_eventParameterList
	return p
}

func InitEmptyEventParameterListContext(p *EventParameterListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_eventParameterList
}

func (*EventParameterListContext) IsEventParameterListContext() {}

func NewEventParameterListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EventParameterListContext {
	var p = new(EventParameterListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_eventParameterList

	return p
}

func (s *EventParameterListContext) GetParser() antlr.Parser { return s.parser }

func (s *EventParameterListContext) AllEventParameter() []IEventParameterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEventParameterContext); ok {
			len++
		}
	}

	tst := make([]IEventParameterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEventParameterContext); ok {
			tst[i] = t.(IEventParameterContext)
			i++
		}
	}

	return tst
}

func (s *EventParameterListContext) EventParameter(i int) IEventParameterContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEventParameterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEventParameterContext)
}

func (s *EventParameterListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EventParameterListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EventParameterListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterEventParameterList(s)
	}
}

func (s *EventParameterListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitEventParameterList(s)
	}
}

func (p *SolidityParser) EventParameterList() (localctx IEventParameterListContext) {
	localctx = NewEventParameterListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, SolidityParserRULE_eventParameterList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(489)
		p.Match(SolidityParserT__22)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(498)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&558451096545148928) != 0) || ((int64((_la-96)) & ^0x3f) == 0 && ((int64(1)<<(_la-96))&6983778429) != 0) {
		{
			p.SetState(490)
			p.EventParameter()
		}
		p.SetState(495)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == SolidityParserT__15 {
			{
				p.SetState(491)
				p.Match(SolidityParserT__15)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(492)
				p.EventParameter()
			}

			p.SetState(497)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(500)
		p.Match(SolidityParserT__23)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEventParameterContext is an interface to support dynamic dispatch.
type IEventParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypeName() ITypeNameContext
	IndexedKeyword() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsEventParameterContext differentiates from other interfaces.
	IsEventParameterContext()
}

type EventParameterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEventParameterContext() *EventParameterContext {
	var p = new(EventParameterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_eventParameter
	return p
}

func InitEmptyEventParameterContext(p *EventParameterContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_eventParameter
}

func (*EventParameterContext) IsEventParameterContext() {}

func NewEventParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EventParameterContext {
	var p = new(EventParameterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_eventParameter

	return p
}

func (s *EventParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *EventParameterContext) TypeName() ITypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *EventParameterContext) IndexedKeyword() antlr.TerminalNode {
	return s.GetToken(SolidityParserIndexedKeyword, 0)
}

func (s *EventParameterContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *EventParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EventParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EventParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterEventParameter(s)
	}
}

func (s *EventParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitEventParameter(s)
	}
}

func (p *SolidityParser) EventParameter() (localctx IEventParameterContext) {
	localctx = NewEventParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, SolidityParserRULE_eventParameter)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(502)
		p.typeName(0)
	}
	p.SetState(504)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SolidityParserIndexedKeyword {
		{
			p.SetState(503)
			p.Match(SolidityParserIndexedKeyword)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(507)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&18018796589563904) != 0) || ((int64((_la-96)) & ^0x3f) == 0 && ((int64(1)<<(_la-96))&6983778305) != 0) {
		{
			p.SetState(506)
			p.Identifier()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionTypeParameterListContext is an interface to support dynamic dispatch.
type IFunctionTypeParameterListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllFunctionTypeParameter() []IFunctionTypeParameterContext
	FunctionTypeParameter(i int) IFunctionTypeParameterContext

	// IsFunctionTypeParameterListContext differentiates from other interfaces.
	IsFunctionTypeParameterListContext()
}

type FunctionTypeParameterListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionTypeParameterListContext() *FunctionTypeParameterListContext {
	var p = new(FunctionTypeParameterListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_functionTypeParameterList
	return p
}

func InitEmptyFunctionTypeParameterListContext(p *FunctionTypeParameterListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_functionTypeParameterList
}

func (*FunctionTypeParameterListContext) IsFunctionTypeParameterListContext() {}

func NewFunctionTypeParameterListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionTypeParameterListContext {
	var p = new(FunctionTypeParameterListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_functionTypeParameterList

	return p
}

func (s *FunctionTypeParameterListContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionTypeParameterListContext) AllFunctionTypeParameter() []IFunctionTypeParameterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFunctionTypeParameterContext); ok {
			len++
		}
	}

	tst := make([]IFunctionTypeParameterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFunctionTypeParameterContext); ok {
			tst[i] = t.(IFunctionTypeParameterContext)
			i++
		}
	}

	return tst
}

func (s *FunctionTypeParameterListContext) FunctionTypeParameter(i int) IFunctionTypeParameterContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionTypeParameterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionTypeParameterContext)
}

func (s *FunctionTypeParameterListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionTypeParameterListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionTypeParameterListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterFunctionTypeParameterList(s)
	}
}

func (s *FunctionTypeParameterListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitFunctionTypeParameterList(s)
	}
}

func (p *SolidityParser) FunctionTypeParameterList() (localctx IFunctionTypeParameterListContext) {
	localctx = NewFunctionTypeParameterListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, SolidityParserRULE_functionTypeParameterList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(509)
		p.Match(SolidityParserT__22)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(518)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&558451096545148928) != 0) || ((int64((_la-96)) & ^0x3f) == 0 && ((int64(1)<<(_la-96))&6983778429) != 0) {
		{
			p.SetState(510)
			p.FunctionTypeParameter()
		}
		p.SetState(515)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == SolidityParserT__15 {
			{
				p.SetState(511)
				p.Match(SolidityParserT__15)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(512)
				p.FunctionTypeParameter()
			}

			p.SetState(517)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(520)
		p.Match(SolidityParserT__23)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionTypeParameterContext is an interface to support dynamic dispatch.
type IFunctionTypeParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypeName() ITypeNameContext
	StorageLocation() IStorageLocationContext

	// IsFunctionTypeParameterContext differentiates from other interfaces.
	IsFunctionTypeParameterContext()
}

type FunctionTypeParameterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionTypeParameterContext() *FunctionTypeParameterContext {
	var p = new(FunctionTypeParameterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_functionTypeParameter
	return p
}

func InitEmptyFunctionTypeParameterContext(p *FunctionTypeParameterContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_functionTypeParameter
}

func (*FunctionTypeParameterContext) IsFunctionTypeParameterContext() {}

func NewFunctionTypeParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionTypeParameterContext {
	var p = new(FunctionTypeParameterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_functionTypeParameter

	return p
}

func (s *FunctionTypeParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionTypeParameterContext) TypeName() ITypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *FunctionTypeParameterContext) StorageLocation() IStorageLocationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStorageLocationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStorageLocationContext)
}

func (s *FunctionTypeParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionTypeParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionTypeParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterFunctionTypeParameter(s)
	}
}

func (s *FunctionTypeParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitFunctionTypeParameter(s)
	}
}

func (p *SolidityParser) FunctionTypeParameter() (localctx IFunctionTypeParameterContext) {
	localctx = NewFunctionTypeParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, SolidityParserRULE_functionTypeParameter)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(522)
		p.typeName(0)
	}
	p.SetState(524)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&7696581394432) != 0 {
		{
			p.SetState(523)
			p.StorageLocation()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVariableDeclarationContext is an interface to support dynamic dispatch.
type IVariableDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypeName() ITypeNameContext
	Identifier() IIdentifierContext
	StorageLocation() IStorageLocationContext

	// IsVariableDeclarationContext differentiates from other interfaces.
	IsVariableDeclarationContext()
}

type VariableDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableDeclarationContext() *VariableDeclarationContext {
	var p = new(VariableDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_variableDeclaration
	return p
}

func InitEmptyVariableDeclarationContext(p *VariableDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_variableDeclaration
}

func (*VariableDeclarationContext) IsVariableDeclarationContext() {}

func NewVariableDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableDeclarationContext {
	var p = new(VariableDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_variableDeclaration

	return p
}

func (s *VariableDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableDeclarationContext) TypeName() ITypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *VariableDeclarationContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *VariableDeclarationContext) StorageLocation() IStorageLocationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStorageLocationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStorageLocationContext)
}

func (s *VariableDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterVariableDeclaration(s)
	}
}

func (s *VariableDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitVariableDeclaration(s)
	}
}

func (p *SolidityParser) VariableDeclaration() (localctx IVariableDeclarationContext) {
	localctx = NewVariableDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, SolidityParserRULE_variableDeclaration)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(526)
		p.typeName(0)
	}
	p.SetState(528)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 53, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(527)
			p.StorageLocation()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(530)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeNameContext is an interface to support dynamic dispatch.
type ITypeNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ElementaryTypeName() IElementaryTypeNameContext
	UserDefinedTypeName() IUserDefinedTypeNameContext
	Mapping() IMappingContext
	FunctionTypeName() IFunctionTypeNameContext
	PayableKeyword() antlr.TerminalNode
	TypeName() ITypeNameContext
	Expression() IExpressionContext

	// IsTypeNameContext differentiates from other interfaces.
	IsTypeNameContext()
}

type TypeNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeNameContext() *TypeNameContext {
	var p = new(TypeNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_typeName
	return p
}

func InitEmptyTypeNameContext(p *TypeNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_typeName
}

func (*TypeNameContext) IsTypeNameContext() {}

func NewTypeNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeNameContext {
	var p = new(TypeNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_typeName

	return p
}

func (s *TypeNameContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeNameContext) ElementaryTypeName() IElementaryTypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementaryTypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementaryTypeNameContext)
}

func (s *TypeNameContext) UserDefinedTypeName() IUserDefinedTypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserDefinedTypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserDefinedTypeNameContext)
}

func (s *TypeNameContext) Mapping() IMappingContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMappingContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMappingContext)
}

func (s *TypeNameContext) FunctionTypeName() IFunctionTypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionTypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionTypeNameContext)
}

func (s *TypeNameContext) PayableKeyword() antlr.TerminalNode {
	return s.GetToken(SolidityParserPayableKeyword, 0)
}

func (s *TypeNameContext) TypeName() ITypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *TypeNameContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *TypeNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterTypeName(s)
	}
}

func (s *TypeNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitTypeName(s)
	}
}

func (p *SolidityParser) TypeName() (localctx ITypeNameContext) {
	return p.typeName(0)
}

func (p *SolidityParser) typeName(_p int) (localctx ITypeNameContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewTypeNameContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx ITypeNameContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 68
	p.EnterRecursionRule(localctx, 68, SolidityParserRULE_typeName, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(539)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 54, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(533)
			p.ElementaryTypeName()
		}

	case 2:
		{
			p.SetState(534)
			p.UserDefinedTypeName()
		}

	case 3:
		{
			p.SetState(535)
			p.Mapping()
		}

	case 4:
		{
			p.SetState(536)
			p.FunctionTypeName()
		}

	case 5:
		{
			p.SetState(537)
			p.Match(SolidityParserT__35)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(538)
			p.Match(SolidityParserPayableKeyword)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(549)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 56, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewTypeNameContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, SolidityParserRULE_typeName)
			p.SetState(541)

			if !(p.Precpred(p.GetParserRuleContext(), 3)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
				goto errorExit
			}
			{
				p.SetState(542)
				p.Match(SolidityParserT__33)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(544)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if ((int64((_la-5)) & ^0x3f) == 0 && ((int64(1)<<(_la-5))&9078694038950117889) != 0) || ((int64((_la-96)) & ^0x3f) == 0 && ((int64(1)<<(_la-96))&15707933693) != 0) {
				{
					p.SetState(543)
					p.expression(0)
				}

			}
			{
				p.SetState(546)
				p.Match(SolidityParserT__34)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(551)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 56, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUserDefinedTypeNameContext is an interface to support dynamic dispatch.
type IUserDefinedTypeNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext

	// IsUserDefinedTypeNameContext differentiates from other interfaces.
	IsUserDefinedTypeNameContext()
}

type UserDefinedTypeNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUserDefinedTypeNameContext() *UserDefinedTypeNameContext {
	var p = new(UserDefinedTypeNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_userDefinedTypeName
	return p
}

func InitEmptyUserDefinedTypeNameContext(p *UserDefinedTypeNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_userDefinedTypeName
}

func (*UserDefinedTypeNameContext) IsUserDefinedTypeNameContext() {}

func NewUserDefinedTypeNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UserDefinedTypeNameContext {
	var p = new(UserDefinedTypeNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_userDefinedTypeName

	return p
}

func (s *UserDefinedTypeNameContext) GetParser() antlr.Parser { return s.parser }

func (s *UserDefinedTypeNameContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *UserDefinedTypeNameContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *UserDefinedTypeNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UserDefinedTypeNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UserDefinedTypeNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterUserDefinedTypeName(s)
	}
}

func (s *UserDefinedTypeNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitUserDefinedTypeName(s)
	}
}

func (p *SolidityParser) UserDefinedTypeName() (localctx IUserDefinedTypeNameContext) {
	localctx = NewUserDefinedTypeNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, SolidityParserRULE_userDefinedTypeName)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(552)
		p.Identifier()
	}
	p.SetState(557)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 57, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(553)
				p.Match(SolidityParserT__36)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(554)
				p.Identifier()
			}

		}
		p.SetState(559)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 57, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMappingKeyContext is an interface to support dynamic dispatch.
type IMappingKeyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ElementaryTypeName() IElementaryTypeNameContext
	UserDefinedTypeName() IUserDefinedTypeNameContext

	// IsMappingKeyContext differentiates from other interfaces.
	IsMappingKeyContext()
}

type MappingKeyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMappingKeyContext() *MappingKeyContext {
	var p = new(MappingKeyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_mappingKey
	return p
}

func InitEmptyMappingKeyContext(p *MappingKeyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_mappingKey
}

func (*MappingKeyContext) IsMappingKeyContext() {}

func NewMappingKeyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MappingKeyContext {
	var p = new(MappingKeyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_mappingKey

	return p
}

func (s *MappingKeyContext) GetParser() antlr.Parser { return s.parser }

func (s *MappingKeyContext) ElementaryTypeName() IElementaryTypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementaryTypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementaryTypeNameContext)
}

func (s *MappingKeyContext) UserDefinedTypeName() IUserDefinedTypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserDefinedTypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserDefinedTypeNameContext)
}

func (s *MappingKeyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MappingKeyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MappingKeyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterMappingKey(s)
	}
}

func (s *MappingKeyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitMappingKey(s)
	}
}

func (p *SolidityParser) MappingKey() (localctx IMappingKeyContext) {
	localctx = NewMappingKeyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, SolidityParserRULE_mappingKey)
	p.SetState(562)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SolidityParserT__35, SolidityParserT__54, SolidityParserT__55, SolidityParserT__56, SolidityParserT__57, SolidityParserInt, SolidityParserUint, SolidityParserByte, SolidityParserFixed, SolidityParserUfixed:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(560)
			p.ElementaryTypeName()
		}

	case SolidityParserT__13, SolidityParserT__24, SolidityParserT__41, SolidityParserT__53, SolidityParserT__95, SolidityParserLeaveKeyword, SolidityParserPayableKeyword, SolidityParserConstructorKeyword, SolidityParserReceiveKeyword, SolidityParserIdentifier:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(561)
			p.UserDefinedTypeName()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMappingContext is an interface to support dynamic dispatch.
type IMappingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MappingKey() IMappingKeyContext
	TypeName() ITypeNameContext

	// IsMappingContext differentiates from other interfaces.
	IsMappingContext()
}

type MappingContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMappingContext() *MappingContext {
	var p = new(MappingContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_mapping
	return p
}

func InitEmptyMappingContext(p *MappingContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_mapping
}

func (*MappingContext) IsMappingContext() {}

func NewMappingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MappingContext {
	var p = new(MappingContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_mapping

	return p
}

func (s *MappingContext) GetParser() antlr.Parser { return s.parser }

func (s *MappingContext) MappingKey() IMappingKeyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMappingKeyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMappingKeyContext)
}

func (s *MappingContext) TypeName() ITypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *MappingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MappingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MappingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterMapping(s)
	}
}

func (s *MappingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitMapping(s)
	}
}

func (p *SolidityParser) Mapping() (localctx IMappingContext) {
	localctx = NewMappingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, SolidityParserRULE_mapping)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(564)
		p.Match(SolidityParserT__37)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(565)
		p.Match(SolidityParserT__22)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(566)
		p.MappingKey()
	}
	{
		p.SetState(567)
		p.Match(SolidityParserT__38)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(568)
		p.typeName(0)
	}
	{
		p.SetState(569)
		p.Match(SolidityParserT__23)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionTypeNameContext is an interface to support dynamic dispatch.
type IFunctionTypeNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllFunctionTypeParameterList() []IFunctionTypeParameterListContext
	FunctionTypeParameterList(i int) IFunctionTypeParameterListContext
	AllInternalKeyword() []antlr.TerminalNode
	InternalKeyword(i int) antlr.TerminalNode
	AllExternalKeyword() []antlr.TerminalNode
	ExternalKeyword(i int) antlr.TerminalNode
	AllStateMutability() []IStateMutabilityContext
	StateMutability(i int) IStateMutabilityContext

	// IsFunctionTypeNameContext differentiates from other interfaces.
	IsFunctionTypeNameContext()
}

type FunctionTypeNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionTypeNameContext() *FunctionTypeNameContext {
	var p = new(FunctionTypeNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_functionTypeName
	return p
}

func InitEmptyFunctionTypeNameContext(p *FunctionTypeNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_functionTypeName
}

func (*FunctionTypeNameContext) IsFunctionTypeNameContext() {}

func NewFunctionTypeNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionTypeNameContext {
	var p = new(FunctionTypeNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_functionTypeName

	return p
}

func (s *FunctionTypeNameContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionTypeNameContext) AllFunctionTypeParameterList() []IFunctionTypeParameterListContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFunctionTypeParameterListContext); ok {
			len++
		}
	}

	tst := make([]IFunctionTypeParameterListContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFunctionTypeParameterListContext); ok {
			tst[i] = t.(IFunctionTypeParameterListContext)
			i++
		}
	}

	return tst
}

func (s *FunctionTypeNameContext) FunctionTypeParameterList(i int) IFunctionTypeParameterListContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionTypeParameterListContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionTypeParameterListContext)
}

func (s *FunctionTypeNameContext) AllInternalKeyword() []antlr.TerminalNode {
	return s.GetTokens(SolidityParserInternalKeyword)
}

func (s *FunctionTypeNameContext) InternalKeyword(i int) antlr.TerminalNode {
	return s.GetToken(SolidityParserInternalKeyword, i)
}

func (s *FunctionTypeNameContext) AllExternalKeyword() []antlr.TerminalNode {
	return s.GetTokens(SolidityParserExternalKeyword)
}

func (s *FunctionTypeNameContext) ExternalKeyword(i int) antlr.TerminalNode {
	return s.GetToken(SolidityParserExternalKeyword, i)
}

func (s *FunctionTypeNameContext) AllStateMutability() []IStateMutabilityContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStateMutabilityContext); ok {
			len++
		}
	}

	tst := make([]IStateMutabilityContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStateMutabilityContext); ok {
			tst[i] = t.(IStateMutabilityContext)
			i++
		}
	}

	return tst
}

func (s *FunctionTypeNameContext) StateMutability(i int) IStateMutabilityContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStateMutabilityContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStateMutabilityContext)
}

func (s *FunctionTypeNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionTypeNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionTypeNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterFunctionTypeName(s)
	}
}

func (s *FunctionTypeNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitFunctionTypeName(s)
	}
}

func (p *SolidityParser) FunctionTypeName() (localctx IFunctionTypeNameContext) {
	localctx = NewFunctionTypeNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, SolidityParserRULE_functionTypeName)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(571)
		p.Match(SolidityParserT__29)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(572)
		p.FunctionTypeParameterList()
	}
	p.SetState(578)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 60, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(576)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case SolidityParserInternalKeyword:
				{
					p.SetState(573)
					p.Match(SolidityParserInternalKeyword)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case SolidityParserExternalKeyword:
				{
					p.SetState(574)
					p.Match(SolidityParserExternalKeyword)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case SolidityParserConstantKeyword, SolidityParserPayableKeyword, SolidityParserPureKeyword, SolidityParserViewKeyword:
				{
					p.SetState(575)
					p.StateMutability()
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

		}
		p.SetState(580)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 60, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(583)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 61, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(581)
			p.Match(SolidityParserT__30)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(582)
			p.FunctionTypeParameterList()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStorageLocationContext is an interface to support dynamic dispatch.
type IStorageLocationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsStorageLocationContext differentiates from other interfaces.
	IsStorageLocationContext()
}

type StorageLocationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStorageLocationContext() *StorageLocationContext {
	var p = new(StorageLocationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_storageLocation
	return p
}

func InitEmptyStorageLocationContext(p *StorageLocationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_storageLocation
}

func (*StorageLocationContext) IsStorageLocationContext() {}

func NewStorageLocationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StorageLocationContext {
	var p = new(StorageLocationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_storageLocation

	return p
}

func (s *StorageLocationContext) GetParser() antlr.Parser { return s.parser }
func (s *StorageLocationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StorageLocationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StorageLocationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterStorageLocation(s)
	}
}

func (s *StorageLocationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitStorageLocation(s)
	}
}

func (p *SolidityParser) StorageLocation() (localctx IStorageLocationContext) {
	localctx = NewStorageLocationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, SolidityParserRULE_storageLocation)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(585)
		_la = p.GetTokenStream().LA(1)

		if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&7696581394432) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStateMutabilityContext is an interface to support dynamic dispatch.
type IStateMutabilityContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PureKeyword() antlr.TerminalNode
	ConstantKeyword() antlr.TerminalNode
	ViewKeyword() antlr.TerminalNode
	PayableKeyword() antlr.TerminalNode

	// IsStateMutabilityContext differentiates from other interfaces.
	IsStateMutabilityContext()
}

type StateMutabilityContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStateMutabilityContext() *StateMutabilityContext {
	var p = new(StateMutabilityContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_stateMutability
	return p
}

func InitEmptyStateMutabilityContext(p *StateMutabilityContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_stateMutability
}

func (*StateMutabilityContext) IsStateMutabilityContext() {}

func NewStateMutabilityContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StateMutabilityContext {
	var p = new(StateMutabilityContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_stateMutability

	return p
}

func (s *StateMutabilityContext) GetParser() antlr.Parser { return s.parser }

func (s *StateMutabilityContext) PureKeyword() antlr.TerminalNode {
	return s.GetToken(SolidityParserPureKeyword, 0)
}

func (s *StateMutabilityContext) ConstantKeyword() antlr.TerminalNode {
	return s.GetToken(SolidityParserConstantKeyword, 0)
}

func (s *StateMutabilityContext) ViewKeyword() antlr.TerminalNode {
	return s.GetToken(SolidityParserViewKeyword, 0)
}

func (s *StateMutabilityContext) PayableKeyword() antlr.TerminalNode {
	return s.GetToken(SolidityParserPayableKeyword, 0)
}

func (s *StateMutabilityContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StateMutabilityContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StateMutabilityContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterStateMutability(s)
	}
}

func (s *StateMutabilityContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitStateMutability(s)
	}
}

func (p *SolidityParser) StateMutability() (localctx IStateMutabilityContext) {
	localctx = NewStateMutabilityContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, SolidityParserRULE_stateMutability)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(587)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-111)) & ^0x3f) == 0 && ((int64(1)<<(_la-111))&10369) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBlockContext is an interface to support dynamic dispatch.
type IBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllStatement() []IStatementContext
	Statement(i int) IStatementContext

	// IsBlockContext differentiates from other interfaces.
	IsBlockContext()
}

type BlockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlockContext() *BlockContext {
	var p = new(BlockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_block
	return p
}

func InitEmptyBlockContext(p *BlockContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_block
}

func (*BlockContext) IsBlockContext() {}

func NewBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BlockContext {
	var p = new(BlockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_block

	return p
}

func (s *BlockContext) GetParser() antlr.Parser { return s.parser }

func (s *BlockContext) AllStatement() []IStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementContext); ok {
			len++
		}
	}

	tst := make([]IStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementContext); ok {
			tst[i] = t.(IStatementContext)
			i++
		}
	}

	return tst
}

func (s *BlockContext) Statement(i int) IStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *BlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterBlock(s)
	}
}

func (s *BlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitBlock(s)
	}
}

func (p *SolidityParser) Block() (localctx IBlockContext) {
	localctx = NewBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, SolidityParserRULE_block)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(589)
		p.Match(SolidityParserT__14)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(593)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64((_la-5)) & ^0x3f) == 0 && ((int64(1)<<(_la-5))&9079253973874247169) != 0) || ((int64((_la-96)) & ^0x3f) == 0 && ((int64(1)<<(_la-96))&15708081149) != 0) {
		{
			p.SetState(590)
			p.Statement()
		}

		p.SetState(595)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(596)
		p.Match(SolidityParserT__16)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStatementContext is an interface to support dynamic dispatch.
type IStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IfStatement() IIfStatementContext
	TryStatement() ITryStatementContext
	WhileStatement() IWhileStatementContext
	ForStatement() IForStatementContext
	Block() IBlockContext
	InlineAssemblyStatement() IInlineAssemblyStatementContext
	DoWhileStatement() IDoWhileStatementContext
	ContinueStatement() IContinueStatementContext
	BreakStatement() IBreakStatementContext
	ReturnStatement() IReturnStatementContext
	ThrowStatement() IThrowStatementContext
	EmitStatement() IEmitStatementContext
	SimpleStatement() ISimpleStatementContext
	UncheckedStatement() IUncheckedStatementContext
	RevertStatement() IRevertStatementContext

	// IsStatementContext differentiates from other interfaces.
	IsStatementContext()
}

type StatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementContext() *StatementContext {
	var p = new(StatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_statement
	return p
}

func InitEmptyStatementContext(p *StatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_statement
}

func (*StatementContext) IsStatementContext() {}

func NewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementContext {
	var p = new(StatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_statement

	return p
}

func (s *StatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementContext) IfStatement() IIfStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfStatementContext)
}

func (s *StatementContext) TryStatement() ITryStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITryStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITryStatementContext)
}

func (s *StatementContext) WhileStatement() IWhileStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhileStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhileStatementContext)
}

func (s *StatementContext) ForStatement() IForStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForStatementContext)
}

func (s *StatementContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *StatementContext) InlineAssemblyStatement() IInlineAssemblyStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInlineAssemblyStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInlineAssemblyStatementContext)
}

func (s *StatementContext) DoWhileStatement() IDoWhileStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDoWhileStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDoWhileStatementContext)
}

func (s *StatementContext) ContinueStatement() IContinueStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IContinueStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IContinueStatementContext)
}

func (s *StatementContext) BreakStatement() IBreakStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBreakStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBreakStatementContext)
}

func (s *StatementContext) ReturnStatement() IReturnStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReturnStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReturnStatementContext)
}

func (s *StatementContext) ThrowStatement() IThrowStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IThrowStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IThrowStatementContext)
}

func (s *StatementContext) EmitStatement() IEmitStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEmitStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEmitStatementContext)
}

func (s *StatementContext) SimpleStatement() ISimpleStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleStatementContext)
}

func (s *StatementContext) UncheckedStatement() IUncheckedStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUncheckedStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUncheckedStatementContext)
}

func (s *StatementContext) RevertStatement() IRevertStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRevertStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRevertStatementContext)
}

func (s *StatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterStatement(s)
	}
}

func (s *StatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitStatement(s)
	}
}

func (p *SolidityParser) Statement() (localctx IStatementContext) {
	localctx = NewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, SolidityParserRULE_statement)
	p.SetState(613)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 63, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(598)
			p.IfStatement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(599)
			p.TryStatement()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(600)
			p.WhileStatement()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(601)
			p.ForStatement()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(602)
			p.Block()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(603)
			p.InlineAssemblyStatement()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(604)
			p.DoWhileStatement()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(605)
			p.ContinueStatement()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(606)
			p.BreakStatement()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(607)
			p.ReturnStatement()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(608)
			p.ThrowStatement()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(609)
			p.EmitStatement()
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(610)
			p.SimpleStatement()
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(611)
			p.UncheckedStatement()
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(612)
			p.RevertStatement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpressionStatementContext is an interface to support dynamic dispatch.
type IExpressionStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext

	// IsExpressionStatementContext differentiates from other interfaces.
	IsExpressionStatementContext()
}

type ExpressionStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionStatementContext() *ExpressionStatementContext {
	var p = new(ExpressionStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_expressionStatement
	return p
}

func InitEmptyExpressionStatementContext(p *ExpressionStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_expressionStatement
}

func (*ExpressionStatementContext) IsExpressionStatementContext() {}

func NewExpressionStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionStatementContext {
	var p = new(ExpressionStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_expressionStatement

	return p
}

func (s *ExpressionStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExpressionStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterExpressionStatement(s)
	}
}

func (s *ExpressionStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitExpressionStatement(s)
	}
}

func (p *SolidityParser) ExpressionStatement() (localctx IExpressionStatementContext) {
	localctx = NewExpressionStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, SolidityParserRULE_expressionStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(615)
		p.expression(0)
	}
	{
		p.SetState(616)
		p.Match(SolidityParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIfStatementContext is an interface to support dynamic dispatch.
type IIfStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext
	AllStatement() []IStatementContext
	Statement(i int) IStatementContext

	// IsIfStatementContext differentiates from other interfaces.
	IsIfStatementContext()
}

type IfStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIfStatementContext() *IfStatementContext {
	var p = new(IfStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_ifStatement
	return p
}

func InitEmptyIfStatementContext(p *IfStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_ifStatement
}

func (*IfStatementContext) IsIfStatementContext() {}

func NewIfStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfStatementContext {
	var p = new(IfStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_ifStatement

	return p
}

func (s *IfStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *IfStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *IfStatementContext) AllStatement() []IStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementContext); ok {
			len++
		}
	}

	tst := make([]IStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementContext); ok {
			tst[i] = t.(IStatementContext)
			i++
		}
	}

	return tst
}

func (s *IfStatementContext) Statement(i int) IStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *IfStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterIfStatement(s)
	}
}

func (s *IfStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitIfStatement(s)
	}
}

func (p *SolidityParser) IfStatement() (localctx IIfStatementContext) {
	localctx = NewIfStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, SolidityParserRULE_ifStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(618)
		p.Match(SolidityParserT__42)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(619)
		p.Match(SolidityParserT__22)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(620)
		p.expression(0)
	}
	{
		p.SetState(621)
		p.Match(SolidityParserT__23)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(622)
		p.Statement()
	}
	p.SetState(625)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 64, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(623)
			p.Match(SolidityParserT__43)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(624)
			p.Statement()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITryStatementContext is an interface to support dynamic dispatch.
type ITryStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext
	Block() IBlockContext
	ReturnParameters() IReturnParametersContext
	AllCatchClause() []ICatchClauseContext
	CatchClause(i int) ICatchClauseContext

	// IsTryStatementContext differentiates from other interfaces.
	IsTryStatementContext()
}

type TryStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTryStatementContext() *TryStatementContext {
	var p = new(TryStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_tryStatement
	return p
}

func InitEmptyTryStatementContext(p *TryStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_tryStatement
}

func (*TryStatementContext) IsTryStatementContext() {}

func NewTryStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TryStatementContext {
	var p = new(TryStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_tryStatement

	return p
}

func (s *TryStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *TryStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *TryStatementContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *TryStatementContext) ReturnParameters() IReturnParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReturnParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReturnParametersContext)
}

func (s *TryStatementContext) AllCatchClause() []ICatchClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICatchClauseContext); ok {
			len++
		}
	}

	tst := make([]ICatchClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICatchClauseContext); ok {
			tst[i] = t.(ICatchClauseContext)
			i++
		}
	}

	return tst
}

func (s *TryStatementContext) CatchClause(i int) ICatchClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICatchClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICatchClauseContext)
}

func (s *TryStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TryStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TryStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterTryStatement(s)
	}
}

func (s *TryStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitTryStatement(s)
	}
}

func (p *SolidityParser) TryStatement() (localctx ITryStatementContext) {
	localctx = NewTryStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, SolidityParserRULE_tryStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(627)
		p.Match(SolidityParserT__44)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(628)
		p.expression(0)
	}
	p.SetState(630)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SolidityParserT__30 {
		{
			p.SetState(629)
			p.ReturnParameters()
		}

	}
	{
		p.SetState(632)
		p.Block()
	}
	p.SetState(634)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == SolidityParserT__45 {
		{
			p.SetState(633)
			p.CatchClause()
		}

		p.SetState(636)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICatchClauseContext is an interface to support dynamic dispatch.
type ICatchClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Block() IBlockContext
	ParameterList() IParameterListContext
	Identifier() IIdentifierContext

	// IsCatchClauseContext differentiates from other interfaces.
	IsCatchClauseContext()
}

type CatchClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCatchClauseContext() *CatchClauseContext {
	var p = new(CatchClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_catchClause
	return p
}

func InitEmptyCatchClauseContext(p *CatchClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_catchClause
}

func (*CatchClauseContext) IsCatchClauseContext() {}

func NewCatchClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CatchClauseContext {
	var p = new(CatchClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_catchClause

	return p
}

func (s *CatchClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *CatchClauseContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *CatchClauseContext) ParameterList() IParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterListContext)
}

func (s *CatchClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CatchClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CatchClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CatchClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterCatchClause(s)
	}
}

func (s *CatchClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitCatchClause(s)
	}
}

func (p *SolidityParser) CatchClause() (localctx ICatchClauseContext) {
	localctx = NewCatchClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, SolidityParserRULE_catchClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(638)
		p.Match(SolidityParserT__45)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(643)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&18018796597952512) != 0) || ((int64((_la-96)) & ^0x3f) == 0 && ((int64(1)<<(_la-96))&6983778305) != 0) {
		p.SetState(640)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&18018796589563904) != 0) || ((int64((_la-96)) & ^0x3f) == 0 && ((int64(1)<<(_la-96))&6983778305) != 0) {
			{
				p.SetState(639)
				p.Identifier()
			}

		}
		{
			p.SetState(642)
			p.ParameterList()
		}

	}
	{
		p.SetState(645)
		p.Block()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWhileStatementContext is an interface to support dynamic dispatch.
type IWhileStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext
	Statement() IStatementContext

	// IsWhileStatementContext differentiates from other interfaces.
	IsWhileStatementContext()
}

type WhileStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhileStatementContext() *WhileStatementContext {
	var p = new(WhileStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_whileStatement
	return p
}

func InitEmptyWhileStatementContext(p *WhileStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_whileStatement
}

func (*WhileStatementContext) IsWhileStatementContext() {}

func NewWhileStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhileStatementContext {
	var p = new(WhileStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_whileStatement

	return p
}

func (s *WhileStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *WhileStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *WhileStatementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *WhileStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhileStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhileStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterWhileStatement(s)
	}
}

func (s *WhileStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitWhileStatement(s)
	}
}

func (p *SolidityParser) WhileStatement() (localctx IWhileStatementContext) {
	localctx = NewWhileStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, SolidityParserRULE_whileStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(647)
		p.Match(SolidityParserT__46)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(648)
		p.Match(SolidityParserT__22)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(649)
		p.expression(0)
	}
	{
		p.SetState(650)
		p.Match(SolidityParserT__23)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(651)
		p.Statement()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimpleStatementContext is an interface to support dynamic dispatch.
type ISimpleStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VariableDeclarationStatement() IVariableDeclarationStatementContext
	ExpressionStatement() IExpressionStatementContext

	// IsSimpleStatementContext differentiates from other interfaces.
	IsSimpleStatementContext()
}

type SimpleStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleStatementContext() *SimpleStatementContext {
	var p = new(SimpleStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_simpleStatement
	return p
}

func InitEmptySimpleStatementContext(p *SimpleStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_simpleStatement
}

func (*SimpleStatementContext) IsSimpleStatementContext() {}

func NewSimpleStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleStatementContext {
	var p = new(SimpleStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_simpleStatement

	return p
}

func (s *SimpleStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleStatementContext) VariableDeclarationStatement() IVariableDeclarationStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDeclarationStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDeclarationStatementContext)
}

func (s *SimpleStatementContext) ExpressionStatement() IExpressionStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionStatementContext)
}

func (s *SimpleStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterSimpleStatement(s)
	}
}

func (s *SimpleStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitSimpleStatement(s)
	}
}

func (p *SolidityParser) SimpleStatement() (localctx ISimpleStatementContext) {
	localctx = NewSimpleStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, SolidityParserRULE_simpleStatement)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(655)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 69, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(653)
			p.VariableDeclarationStatement()
		}

	case 2:
		{
			p.SetState(654)
			p.ExpressionStatement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUncheckedStatementContext is an interface to support dynamic dispatch.
type IUncheckedStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Block() IBlockContext

	// IsUncheckedStatementContext differentiates from other interfaces.
	IsUncheckedStatementContext()
}

type UncheckedStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUncheckedStatementContext() *UncheckedStatementContext {
	var p = new(UncheckedStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_uncheckedStatement
	return p
}

func InitEmptyUncheckedStatementContext(p *UncheckedStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_uncheckedStatement
}

func (*UncheckedStatementContext) IsUncheckedStatementContext() {}

func NewUncheckedStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UncheckedStatementContext {
	var p = new(UncheckedStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_uncheckedStatement

	return p
}

func (s *UncheckedStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *UncheckedStatementContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *UncheckedStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UncheckedStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UncheckedStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterUncheckedStatement(s)
	}
}

func (s *UncheckedStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitUncheckedStatement(s)
	}
}

func (p *SolidityParser) UncheckedStatement() (localctx IUncheckedStatementContext) {
	localctx = NewUncheckedStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, SolidityParserRULE_uncheckedStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(657)
		p.Match(SolidityParserT__47)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(658)
		p.Block()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IForStatementContext is an interface to support dynamic dispatch.
type IForStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Statement() IStatementContext
	SimpleStatement() ISimpleStatementContext
	ExpressionStatement() IExpressionStatementContext
	Expression() IExpressionContext

	// IsForStatementContext differentiates from other interfaces.
	IsForStatementContext()
}

type ForStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForStatementContext() *ForStatementContext {
	var p = new(ForStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_forStatement
	return p
}

func InitEmptyForStatementContext(p *ForStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_forStatement
}

func (*ForStatementContext) IsForStatementContext() {}

func NewForStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForStatementContext {
	var p = new(ForStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_forStatement

	return p
}

func (s *ForStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ForStatementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *ForStatementContext) SimpleStatement() ISimpleStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleStatementContext)
}

func (s *ForStatementContext) ExpressionStatement() IExpressionStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionStatementContext)
}

func (s *ForStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ForStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterForStatement(s)
	}
}

func (s *ForStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitForStatement(s)
	}
}

func (p *SolidityParser) ForStatement() (localctx IForStatementContext) {
	localctx = NewForStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, SolidityParserRULE_forStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(660)
		p.Match(SolidityParserT__26)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(661)
		p.Match(SolidityParserT__22)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(664)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SolidityParserT__4, SolidityParserT__13, SolidityParserT__22, SolidityParserT__24, SolidityParserT__29, SolidityParserT__33, SolidityParserT__35, SolidityParserT__37, SolidityParserT__41, SolidityParserT__53, SolidityParserT__54, SolidityParserT__55, SolidityParserT__56, SolidityParserT__57, SolidityParserT__58, SolidityParserT__59, SolidityParserT__60, SolidityParserT__62, SolidityParserT__63, SolidityParserT__64, SolidityParserT__65, SolidityParserT__66, SolidityParserT__95, SolidityParserInt, SolidityParserUint, SolidityParserByte, SolidityParserFixed, SolidityParserUfixed, SolidityParserBooleanLiteral, SolidityParserDecimalNumber, SolidityParserHexNumber, SolidityParserHexLiteralFragment, SolidityParserLeaveKeyword, SolidityParserPayableKeyword, SolidityParserTypeKeyword, SolidityParserConstructorKeyword, SolidityParserReceiveKeyword, SolidityParserIdentifier, SolidityParserStringLiteralFragment:
		{
			p.SetState(662)
			p.SimpleStatement()
		}

	case SolidityParserT__1:
		{
			p.SetState(663)
			p.Match(SolidityParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(668)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SolidityParserT__4, SolidityParserT__13, SolidityParserT__22, SolidityParserT__24, SolidityParserT__33, SolidityParserT__35, SolidityParserT__41, SolidityParserT__53, SolidityParserT__54, SolidityParserT__55, SolidityParserT__56, SolidityParserT__57, SolidityParserT__58, SolidityParserT__59, SolidityParserT__60, SolidityParserT__62, SolidityParserT__63, SolidityParserT__64, SolidityParserT__65, SolidityParserT__66, SolidityParserT__95, SolidityParserInt, SolidityParserUint, SolidityParserByte, SolidityParserFixed, SolidityParserUfixed, SolidityParserBooleanLiteral, SolidityParserDecimalNumber, SolidityParserHexNumber, SolidityParserHexLiteralFragment, SolidityParserLeaveKeyword, SolidityParserPayableKeyword, SolidityParserTypeKeyword, SolidityParserConstructorKeyword, SolidityParserReceiveKeyword, SolidityParserIdentifier, SolidityParserStringLiteralFragment:
		{
			p.SetState(666)
			p.ExpressionStatement()
		}

	case SolidityParserT__1:
		{
			p.SetState(667)
			p.Match(SolidityParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(671)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64((_la-5)) & ^0x3f) == 0 && ((int64(1)<<(_la-5))&9078694038950117889) != 0) || ((int64((_la-96)) & ^0x3f) == 0 && ((int64(1)<<(_la-96))&15707933693) != 0) {
		{
			p.SetState(670)
			p.expression(0)
		}

	}
	{
		p.SetState(673)
		p.Match(SolidityParserT__23)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(674)
		p.Statement()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInlineAssemblyStatementContext is an interface to support dynamic dispatch.
type IInlineAssemblyStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AssemblyBlock() IAssemblyBlockContext
	StringLiteralFragment() antlr.TerminalNode

	// IsInlineAssemblyStatementContext differentiates from other interfaces.
	IsInlineAssemblyStatementContext()
}

type InlineAssemblyStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInlineAssemblyStatementContext() *InlineAssemblyStatementContext {
	var p = new(InlineAssemblyStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_inlineAssemblyStatement
	return p
}

func InitEmptyInlineAssemblyStatementContext(p *InlineAssemblyStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_inlineAssemblyStatement
}

func (*InlineAssemblyStatementContext) IsInlineAssemblyStatementContext() {}

func NewInlineAssemblyStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InlineAssemblyStatementContext {
	var p = new(InlineAssemblyStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_inlineAssemblyStatement

	return p
}

func (s *InlineAssemblyStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *InlineAssemblyStatementContext) AssemblyBlock() IAssemblyBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssemblyBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssemblyBlockContext)
}

func (s *InlineAssemblyStatementContext) StringLiteralFragment() antlr.TerminalNode {
	return s.GetToken(SolidityParserStringLiteralFragment, 0)
}

func (s *InlineAssemblyStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InlineAssemblyStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InlineAssemblyStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterInlineAssemblyStatement(s)
	}
}

func (s *InlineAssemblyStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitInlineAssemblyStatement(s)
	}
}

func (p *SolidityParser) InlineAssemblyStatement() (localctx IInlineAssemblyStatementContext) {
	localctx = NewInlineAssemblyStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, SolidityParserRULE_inlineAssemblyStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(676)
		p.Match(SolidityParserT__48)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(678)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SolidityParserStringLiteralFragment {
		{
			p.SetState(677)
			p.Match(SolidityParserStringLiteralFragment)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(680)
		p.AssemblyBlock()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDoWhileStatementContext is an interface to support dynamic dispatch.
type IDoWhileStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Statement() IStatementContext
	Expression() IExpressionContext

	// IsDoWhileStatementContext differentiates from other interfaces.
	IsDoWhileStatementContext()
}

type DoWhileStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDoWhileStatementContext() *DoWhileStatementContext {
	var p = new(DoWhileStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_doWhileStatement
	return p
}

func InitEmptyDoWhileStatementContext(p *DoWhileStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_doWhileStatement
}

func (*DoWhileStatementContext) IsDoWhileStatementContext() {}

func NewDoWhileStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DoWhileStatementContext {
	var p = new(DoWhileStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_doWhileStatement

	return p
}

func (s *DoWhileStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DoWhileStatementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *DoWhileStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *DoWhileStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DoWhileStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DoWhileStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterDoWhileStatement(s)
	}
}

func (s *DoWhileStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitDoWhileStatement(s)
	}
}

func (p *SolidityParser) DoWhileStatement() (localctx IDoWhileStatementContext) {
	localctx = NewDoWhileStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, SolidityParserRULE_doWhileStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(682)
		p.Match(SolidityParserT__49)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(683)
		p.Statement()
	}
	{
		p.SetState(684)
		p.Match(SolidityParserT__46)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(685)
		p.Match(SolidityParserT__22)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(686)
		p.expression(0)
	}
	{
		p.SetState(687)
		p.Match(SolidityParserT__23)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(688)
		p.Match(SolidityParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IContinueStatementContext is an interface to support dynamic dispatch.
type IContinueStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ContinueKeyword() antlr.TerminalNode

	// IsContinueStatementContext differentiates from other interfaces.
	IsContinueStatementContext()
}

type ContinueStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyContinueStatementContext() *ContinueStatementContext {
	var p = new(ContinueStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_continueStatement
	return p
}

func InitEmptyContinueStatementContext(p *ContinueStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_continueStatement
}

func (*ContinueStatementContext) IsContinueStatementContext() {}

func NewContinueStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ContinueStatementContext {
	var p = new(ContinueStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_continueStatement

	return p
}

func (s *ContinueStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ContinueStatementContext) ContinueKeyword() antlr.TerminalNode {
	return s.GetToken(SolidityParserContinueKeyword, 0)
}

func (s *ContinueStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ContinueStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ContinueStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterContinueStatement(s)
	}
}

func (s *ContinueStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitContinueStatement(s)
	}
}

func (p *SolidityParser) ContinueStatement() (localctx IContinueStatementContext) {
	localctx = NewContinueStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, SolidityParserRULE_continueStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(690)
		p.Match(SolidityParserContinueKeyword)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(691)
		p.Match(SolidityParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBreakStatementContext is an interface to support dynamic dispatch.
type IBreakStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BreakKeyword() antlr.TerminalNode

	// IsBreakStatementContext differentiates from other interfaces.
	IsBreakStatementContext()
}

type BreakStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBreakStatementContext() *BreakStatementContext {
	var p = new(BreakStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_breakStatement
	return p
}

func InitEmptyBreakStatementContext(p *BreakStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_breakStatement
}

func (*BreakStatementContext) IsBreakStatementContext() {}

func NewBreakStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BreakStatementContext {
	var p = new(BreakStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_breakStatement

	return p
}

func (s *BreakStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *BreakStatementContext) BreakKeyword() antlr.TerminalNode {
	return s.GetToken(SolidityParserBreakKeyword, 0)
}

func (s *BreakStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BreakStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BreakStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterBreakStatement(s)
	}
}

func (s *BreakStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitBreakStatement(s)
	}
}

func (p *SolidityParser) BreakStatement() (localctx IBreakStatementContext) {
	localctx = NewBreakStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, SolidityParserRULE_breakStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(693)
		p.Match(SolidityParserBreakKeyword)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(694)
		p.Match(SolidityParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReturnStatementContext is an interface to support dynamic dispatch.
type IReturnStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext

	// IsReturnStatementContext differentiates from other interfaces.
	IsReturnStatementContext()
}

type ReturnStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReturnStatementContext() *ReturnStatementContext {
	var p = new(ReturnStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_returnStatement
	return p
}

func InitEmptyReturnStatementContext(p *ReturnStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_returnStatement
}

func (*ReturnStatementContext) IsReturnStatementContext() {}

func NewReturnStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReturnStatementContext {
	var p = new(ReturnStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_returnStatement

	return p
}

func (s *ReturnStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ReturnStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ReturnStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReturnStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReturnStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterReturnStatement(s)
	}
}

func (s *ReturnStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitReturnStatement(s)
	}
}

func (p *SolidityParser) ReturnStatement() (localctx IReturnStatementContext) {
	localctx = NewReturnStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, SolidityParserRULE_returnStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(696)
		p.Match(SolidityParserT__50)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(698)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64((_la-5)) & ^0x3f) == 0 && ((int64(1)<<(_la-5))&9078694038950117889) != 0) || ((int64((_la-96)) & ^0x3f) == 0 && ((int64(1)<<(_la-96))&15707933693) != 0) {
		{
			p.SetState(697)
			p.expression(0)
		}

	}
	{
		p.SetState(700)
		p.Match(SolidityParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IThrowStatementContext is an interface to support dynamic dispatch.
type IThrowStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsThrowStatementContext differentiates from other interfaces.
	IsThrowStatementContext()
}

type ThrowStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyThrowStatementContext() *ThrowStatementContext {
	var p = new(ThrowStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_throwStatement
	return p
}

func InitEmptyThrowStatementContext(p *ThrowStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_throwStatement
}

func (*ThrowStatementContext) IsThrowStatementContext() {}

func NewThrowStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ThrowStatementContext {
	var p = new(ThrowStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_throwStatement

	return p
}

func (s *ThrowStatementContext) GetParser() antlr.Parser { return s.parser }
func (s *ThrowStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ThrowStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ThrowStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterThrowStatement(s)
	}
}

func (s *ThrowStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitThrowStatement(s)
	}
}

func (p *SolidityParser) ThrowStatement() (localctx IThrowStatementContext) {
	localctx = NewThrowStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, SolidityParserRULE_throwStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(702)
		p.Match(SolidityParserT__51)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(703)
		p.Match(SolidityParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEmitStatementContext is an interface to support dynamic dispatch.
type IEmitStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FunctionCall() IFunctionCallContext

	// IsEmitStatementContext differentiates from other interfaces.
	IsEmitStatementContext()
}

type EmitStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEmitStatementContext() *EmitStatementContext {
	var p = new(EmitStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_emitStatement
	return p
}

func InitEmptyEmitStatementContext(p *EmitStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_emitStatement
}

func (*EmitStatementContext) IsEmitStatementContext() {}

func NewEmitStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EmitStatementContext {
	var p = new(EmitStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_emitStatement

	return p
}

func (s *EmitStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *EmitStatementContext) FunctionCall() IFunctionCallContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionCallContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionCallContext)
}

func (s *EmitStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EmitStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EmitStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterEmitStatement(s)
	}
}

func (s *EmitStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitEmitStatement(s)
	}
}

func (p *SolidityParser) EmitStatement() (localctx IEmitStatementContext) {
	localctx = NewEmitStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, SolidityParserRULE_emitStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(705)
		p.Match(SolidityParserT__52)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(706)
		p.FunctionCall()
	}
	{
		p.SetState(707)
		p.Match(SolidityParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRevertStatementContext is an interface to support dynamic dispatch.
type IRevertStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FunctionCall() IFunctionCallContext

	// IsRevertStatementContext differentiates from other interfaces.
	IsRevertStatementContext()
}

type RevertStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRevertStatementContext() *RevertStatementContext {
	var p = new(RevertStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_revertStatement
	return p
}

func InitEmptyRevertStatementContext(p *RevertStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_revertStatement
}

func (*RevertStatementContext) IsRevertStatementContext() {}

func NewRevertStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RevertStatementContext {
	var p = new(RevertStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_revertStatement

	return p
}

func (s *RevertStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *RevertStatementContext) FunctionCall() IFunctionCallContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionCallContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionCallContext)
}

func (s *RevertStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RevertStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RevertStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterRevertStatement(s)
	}
}

func (s *RevertStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitRevertStatement(s)
	}
}

func (p *SolidityParser) RevertStatement() (localctx IRevertStatementContext) {
	localctx = NewRevertStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, SolidityParserRULE_revertStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(709)
		p.Match(SolidityParserT__53)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(710)
		p.FunctionCall()
	}
	{
		p.SetState(711)
		p.Match(SolidityParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVariableDeclarationStatementContext is an interface to support dynamic dispatch.
type IVariableDeclarationStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IdentifierList() IIdentifierListContext
	VariableDeclaration() IVariableDeclarationContext
	VariableDeclarationList() IVariableDeclarationListContext
	Expression() IExpressionContext

	// IsVariableDeclarationStatementContext differentiates from other interfaces.
	IsVariableDeclarationStatementContext()
}

type VariableDeclarationStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableDeclarationStatementContext() *VariableDeclarationStatementContext {
	var p = new(VariableDeclarationStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_variableDeclarationStatement
	return p
}

func InitEmptyVariableDeclarationStatementContext(p *VariableDeclarationStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_variableDeclarationStatement
}

func (*VariableDeclarationStatementContext) IsVariableDeclarationStatementContext() {}

func NewVariableDeclarationStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableDeclarationStatementContext {
	var p = new(VariableDeclarationStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_variableDeclarationStatement

	return p
}

func (s *VariableDeclarationStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableDeclarationStatementContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *VariableDeclarationStatementContext) VariableDeclaration() IVariableDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDeclarationContext)
}

func (s *VariableDeclarationStatementContext) VariableDeclarationList() IVariableDeclarationListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDeclarationListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDeclarationListContext)
}

func (s *VariableDeclarationStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *VariableDeclarationStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableDeclarationStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableDeclarationStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterVariableDeclarationStatement(s)
	}
}

func (s *VariableDeclarationStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitVariableDeclarationStatement(s)
	}
}

func (p *SolidityParser) VariableDeclarationStatement() (localctx IVariableDeclarationStatementContext) {
	localctx = NewVariableDeclarationStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, SolidityParserRULE_variableDeclarationStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(720)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 75, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(713)
			p.Match(SolidityParserT__54)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(714)
			p.IdentifierList()
		}

	case 2:
		{
			p.SetState(715)
			p.VariableDeclaration()
		}

	case 3:
		{
			p.SetState(716)
			p.Match(SolidityParserT__22)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(717)
			p.VariableDeclarationList()
		}
		{
			p.SetState(718)
			p.Match(SolidityParserT__23)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.SetState(724)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SolidityParserT__9 {
		{
			p.SetState(722)
			p.Match(SolidityParserT__9)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(723)
			p.expression(0)
		}

	}
	{
		p.SetState(726)
		p.Match(SolidityParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVariableDeclarationListContext is an interface to support dynamic dispatch.
type IVariableDeclarationListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllVariableDeclaration() []IVariableDeclarationContext
	VariableDeclaration(i int) IVariableDeclarationContext

	// IsVariableDeclarationListContext differentiates from other interfaces.
	IsVariableDeclarationListContext()
}

type VariableDeclarationListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableDeclarationListContext() *VariableDeclarationListContext {
	var p = new(VariableDeclarationListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_variableDeclarationList
	return p
}

func InitEmptyVariableDeclarationListContext(p *VariableDeclarationListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_variableDeclarationList
}

func (*VariableDeclarationListContext) IsVariableDeclarationListContext() {}

func NewVariableDeclarationListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableDeclarationListContext {
	var p = new(VariableDeclarationListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_variableDeclarationList

	return p
}

func (s *VariableDeclarationListContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableDeclarationListContext) AllVariableDeclaration() []IVariableDeclarationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVariableDeclarationContext); ok {
			len++
		}
	}

	tst := make([]IVariableDeclarationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVariableDeclarationContext); ok {
			tst[i] = t.(IVariableDeclarationContext)
			i++
		}
	}

	return tst
}

func (s *VariableDeclarationListContext) VariableDeclaration(i int) IVariableDeclarationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDeclarationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDeclarationContext)
}

func (s *VariableDeclarationListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableDeclarationListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableDeclarationListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterVariableDeclarationList(s)
	}
}

func (s *VariableDeclarationListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitVariableDeclarationList(s)
	}
}

func (p *SolidityParser) VariableDeclarationList() (localctx IVariableDeclarationListContext) {
	localctx = NewVariableDeclarationListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, SolidityParserRULE_variableDeclarationList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(729)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&558451096545148928) != 0) || ((int64((_la-96)) & ^0x3f) == 0 && ((int64(1)<<(_la-96))&6983778429) != 0) {
		{
			p.SetState(728)
			p.VariableDeclaration()
		}

	}
	p.SetState(737)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SolidityParserT__15 {
		{
			p.SetState(731)
			p.Match(SolidityParserT__15)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(733)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&558451096545148928) != 0) || ((int64((_la-96)) & ^0x3f) == 0 && ((int64(1)<<(_la-96))&6983778429) != 0) {
			{
				p.SetState(732)
				p.VariableDeclaration()
			}

		}

		p.SetState(739)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierListContext is an interface to support dynamic dispatch.
type IIdentifierListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext

	// IsIdentifierListContext differentiates from other interfaces.
	IsIdentifierListContext()
}

type IdentifierListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierListContext() *IdentifierListContext {
	var p = new(IdentifierListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_identifierList
	return p
}

func InitEmptyIdentifierListContext(p *IdentifierListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_identifierList
}

func (*IdentifierListContext) IsIdentifierListContext() {}

func NewIdentifierListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierListContext {
	var p = new(IdentifierListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_identifierList

	return p
}

func (s *IdentifierListContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierListContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *IdentifierListContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *IdentifierListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterIdentifierList(s)
	}
}

func (s *IdentifierListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitIdentifierList(s)
	}
}

func (p *SolidityParser) IdentifierList() (localctx IIdentifierListContext) {
	localctx = NewIdentifierListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, SolidityParserRULE_identifierList)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(740)
		p.Match(SolidityParserT__22)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(747)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 81, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(742)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&18018796589563904) != 0) || ((int64((_la-96)) & ^0x3f) == 0 && ((int64(1)<<(_la-96))&6983778305) != 0) {
				{
					p.SetState(741)
					p.Identifier()
				}

			}
			{
				p.SetState(744)
				p.Match(SolidityParserT__15)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(749)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 81, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(751)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&18018796589563904) != 0) || ((int64((_la-96)) & ^0x3f) == 0 && ((int64(1)<<(_la-96))&6983778305) != 0) {
		{
			p.SetState(750)
			p.Identifier()
		}

	}
	{
		p.SetState(753)
		p.Match(SolidityParserT__23)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IElementaryTypeNameContext is an interface to support dynamic dispatch.
type IElementaryTypeNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Int() antlr.TerminalNode
	Uint() antlr.TerminalNode
	Byte() antlr.TerminalNode
	Fixed() antlr.TerminalNode
	Ufixed() antlr.TerminalNode

	// IsElementaryTypeNameContext differentiates from other interfaces.
	IsElementaryTypeNameContext()
}

type ElementaryTypeNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElementaryTypeNameContext() *ElementaryTypeNameContext {
	var p = new(ElementaryTypeNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_elementaryTypeName
	return p
}

func InitEmptyElementaryTypeNameContext(p *ElementaryTypeNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_elementaryTypeName
}

func (*ElementaryTypeNameContext) IsElementaryTypeNameContext() {}

func NewElementaryTypeNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElementaryTypeNameContext {
	var p = new(ElementaryTypeNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_elementaryTypeName

	return p
}

func (s *ElementaryTypeNameContext) GetParser() antlr.Parser { return s.parser }

func (s *ElementaryTypeNameContext) Int() antlr.TerminalNode {
	return s.GetToken(SolidityParserInt, 0)
}

func (s *ElementaryTypeNameContext) Uint() antlr.TerminalNode {
	return s.GetToken(SolidityParserUint, 0)
}

func (s *ElementaryTypeNameContext) Byte() antlr.TerminalNode {
	return s.GetToken(SolidityParserByte, 0)
}

func (s *ElementaryTypeNameContext) Fixed() antlr.TerminalNode {
	return s.GetToken(SolidityParserFixed, 0)
}

func (s *ElementaryTypeNameContext) Ufixed() antlr.TerminalNode {
	return s.GetToken(SolidityParserUfixed, 0)
}

func (s *ElementaryTypeNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElementaryTypeNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElementaryTypeNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterElementaryTypeName(s)
	}
}

func (s *ElementaryTypeNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitElementaryTypeName(s)
	}
}

func (p *SolidityParser) ElementaryTypeName() (localctx IElementaryTypeNameContext) {
	localctx = NewElementaryTypeNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, SolidityParserRULE_elementaryTypeName)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(755)
		_la = p.GetTokenStream().LA(1)

		if !(((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&540432024003936256) != 0) || ((int64((_la-98)) & ^0x3f) == 0 && ((int64(1)<<(_la-98))&31) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpressionContext is an interface to support dynamic dispatch.
type IExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypeName() ITypeNameContext
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	PrimaryExpression() IPrimaryExpressionContext
	Identifier() IIdentifierContext
	NameValueList() INameValueListContext
	FunctionCallArguments() IFunctionCallArgumentsContext

	// IsExpressionContext differentiates from other interfaces.
	IsExpressionContext()
}

type ExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionContext() *ExpressionContext {
	var p = new(ExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_expression
	return p
}

func InitEmptyExpressionContext(p *ExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_expression
}

func (*ExpressionContext) IsExpressionContext() {}

func NewExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionContext {
	var p = new(ExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_expression

	return p
}

func (s *ExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionContext) TypeName() ITypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *ExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExpressionContext) PrimaryExpression() IPrimaryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *ExpressionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ExpressionContext) NameValueList() INameValueListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameValueListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameValueListContext)
}

func (s *ExpressionContext) FunctionCallArguments() IFunctionCallArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionCallArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionCallArgumentsContext)
}

func (s *ExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterExpression(s)
	}
}

func (s *ExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitExpression(s)
	}
}

func (p *SolidityParser) Expression() (localctx IExpressionContext) {
	return p.expression(0)
}

func (p *SolidityParser) expression(_p int) (localctx IExpressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 126
	p.EnterRecursionRule(localctx, 126, SolidityParserRULE_expression, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(775)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 83, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(758)
			p.Match(SolidityParserT__60)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(759)
			p.typeName(0)
		}

	case 2:
		{
			p.SetState(760)
			p.Match(SolidityParserT__22)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(761)
			p.expression(0)
		}
		{
			p.SetState(762)
			p.Match(SolidityParserT__23)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		{
			p.SetState(764)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SolidityParserT__58 || _la == SolidityParserT__59) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(765)
			p.expression(19)
		}

	case 4:
		{
			p.SetState(766)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SolidityParserT__62 || _la == SolidityParserT__63) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(767)
			p.expression(18)
		}

	case 5:
		{
			p.SetState(768)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SolidityParserT__64 || _la == SolidityParserT__65) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(769)
			p.expression(17)
		}

	case 6:
		{
			p.SetState(770)
			p.Match(SolidityParserT__66)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(771)
			p.expression(16)
		}

	case 7:
		{
			p.SetState(772)
			p.Match(SolidityParserT__4)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(773)
			p.expression(15)
		}

	case 8:
		{
			p.SetState(774)
			p.PrimaryExpression()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(851)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 87, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(849)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 86, p.GetParserRuleContext()) {
			case 1:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, SolidityParserRULE_expression)
				p.SetState(777)

				if !(p.Precpred(p.GetParserRuleContext(), 14)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 14)", ""))
					goto errorExit
				}
				{
					p.SetState(778)
					p.Match(SolidityParserT__67)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(779)
					p.expression(15)
				}

			case 2:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, SolidityParserRULE_expression)
				p.SetState(780)

				if !(p.Precpred(p.GetParserRuleContext(), 13)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 13)", ""))
					goto errorExit
				}
				{
					p.SetState(781)
					_la = p.GetTokenStream().LA(1)

					if !((int64((_la-13)) & ^0x3f) == 0 && ((int64(1)<<(_la-13))&216172782113783809) != 0) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(782)
					p.expression(14)
				}

			case 3:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, SolidityParserRULE_expression)
				p.SetState(783)

				if !(p.Precpred(p.GetParserRuleContext(), 12)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 12)", ""))
					goto errorExit
				}
				{
					p.SetState(784)
					_la = p.GetTokenStream().LA(1)

					if !(_la == SolidityParserT__62 || _la == SolidityParserT__63) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(785)
					p.expression(13)
				}

			case 4:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, SolidityParserRULE_expression)
				p.SetState(786)

				if !(p.Precpred(p.GetParserRuleContext(), 11)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 11)", ""))
					goto errorExit
				}
				{
					p.SetState(787)
					_la = p.GetTokenStream().LA(1)

					if !(_la == SolidityParserT__70 || _la == SolidityParserT__71) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(788)
					p.expression(12)
				}

			case 5:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, SolidityParserRULE_expression)
				p.SetState(789)

				if !(p.Precpred(p.GetParserRuleContext(), 10)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 10)", ""))
					goto errorExit
				}
				{
					p.SetState(790)
					p.Match(SolidityParserT__72)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(791)
					p.expression(11)
				}

			case 6:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, SolidityParserRULE_expression)
				p.SetState(792)

				if !(p.Precpred(p.GetParserRuleContext(), 9)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 9)", ""))
					goto errorExit
				}
				{
					p.SetState(793)
					p.Match(SolidityParserT__3)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(794)
					p.expression(10)
				}

			case 7:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, SolidityParserRULE_expression)
				p.SetState(795)

				if !(p.Precpred(p.GetParserRuleContext(), 8)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 8)", ""))
					goto errorExit
				}
				{
					p.SetState(796)
					p.Match(SolidityParserT__73)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(797)
					p.expression(9)
				}

			case 8:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, SolidityParserRULE_expression)
				p.SetState(798)

				if !(p.Precpred(p.GetParserRuleContext(), 7)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 7)", ""))
					goto errorExit
				}
				{
					p.SetState(799)
					_la = p.GetTokenStream().LA(1)

					if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&960) != 0) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(800)
					p.expression(8)
				}

			case 9:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, SolidityParserRULE_expression)
				p.SetState(801)

				if !(p.Precpred(p.GetParserRuleContext(), 6)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 6)", ""))
					goto errorExit
				}
				{
					p.SetState(802)
					_la = p.GetTokenStream().LA(1)

					if !(_la == SolidityParserT__74 || _la == SolidityParserT__75) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(803)
					p.expression(7)
				}

			case 10:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, SolidityParserRULE_expression)
				p.SetState(804)

				if !(p.Precpred(p.GetParserRuleContext(), 5)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 5)", ""))
					goto errorExit
				}
				{
					p.SetState(805)
					p.Match(SolidityParserT__76)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(806)
					p.expression(6)
				}

			case 11:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, SolidityParserRULE_expression)
				p.SetState(807)

				if !(p.Precpred(p.GetParserRuleContext(), 4)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 4)", ""))
					goto errorExit
				}
				{
					p.SetState(808)
					p.Match(SolidityParserT__2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(809)
					p.expression(5)
				}

			case 12:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, SolidityParserRULE_expression)
				p.SetState(810)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
					goto errorExit
				}
				{
					p.SetState(811)
					p.Match(SolidityParserT__77)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(812)
					p.expression(0)
				}
				{
					p.SetState(813)
					p.Match(SolidityParserT__61)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(814)
					p.expression(4)
				}

			case 13:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, SolidityParserRULE_expression)
				p.SetState(816)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
					goto errorExit
				}
				{
					p.SetState(817)
					_la = p.GetTokenStream().LA(1)

					if !(_la == SolidityParserT__9 || ((int64((_la-79)) & ^0x3f) == 0 && ((int64(1)<<(_la-79))&1023) != 0)) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(818)
					p.expression(3)
				}

			case 14:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, SolidityParserRULE_expression)
				p.SetState(819)

				if !(p.Precpred(p.GetParserRuleContext(), 27)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 27)", ""))
					goto errorExit
				}
				{
					p.SetState(820)
					_la = p.GetTokenStream().LA(1)

					if !(_la == SolidityParserT__58 || _la == SolidityParserT__59) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

			case 15:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, SolidityParserRULE_expression)
				p.SetState(821)

				if !(p.Precpred(p.GetParserRuleContext(), 25)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 25)", ""))
					goto errorExit
				}
				{
					p.SetState(822)
					p.Match(SolidityParserT__33)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(823)
					p.expression(0)
				}
				{
					p.SetState(824)
					p.Match(SolidityParserT__34)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case 16:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, SolidityParserRULE_expression)
				p.SetState(826)

				if !(p.Precpred(p.GetParserRuleContext(), 24)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 24)", ""))
					goto errorExit
				}
				{
					p.SetState(827)
					p.Match(SolidityParserT__33)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(829)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if ((int64((_la-5)) & ^0x3f) == 0 && ((int64(1)<<(_la-5))&9078694038950117889) != 0) || ((int64((_la-96)) & ^0x3f) == 0 && ((int64(1)<<(_la-96))&15707933693) != 0) {
					{
						p.SetState(828)
						p.expression(0)
					}

				}
				{
					p.SetState(831)
					p.Match(SolidityParserT__61)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(833)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if ((int64((_la-5)) & ^0x3f) == 0 && ((int64(1)<<(_la-5))&9078694038950117889) != 0) || ((int64((_la-96)) & ^0x3f) == 0 && ((int64(1)<<(_la-96))&15707933693) != 0) {
					{
						p.SetState(832)
						p.expression(0)
					}

				}
				{
					p.SetState(835)
					p.Match(SolidityParserT__34)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case 17:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, SolidityParserRULE_expression)
				p.SetState(836)

				if !(p.Precpred(p.GetParserRuleContext(), 23)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 23)", ""))
					goto errorExit
				}
				{
					p.SetState(837)
					p.Match(SolidityParserT__36)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(838)
					p.Identifier()
				}

			case 18:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, SolidityParserRULE_expression)
				p.SetState(839)

				if !(p.Precpred(p.GetParserRuleContext(), 22)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 22)", ""))
					goto errorExit
				}
				{
					p.SetState(840)
					p.Match(SolidityParserT__14)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(841)
					p.NameValueList()
				}
				{
					p.SetState(842)
					p.Match(SolidityParserT__16)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case 19:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, SolidityParserRULE_expression)
				p.SetState(844)

				if !(p.Precpred(p.GetParserRuleContext(), 21)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 21)", ""))
					goto errorExit
				}
				{
					p.SetState(845)
					p.Match(SolidityParserT__22)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(846)
					p.FunctionCallArguments()
				}
				{
					p.SetState(847)
					p.Match(SolidityParserT__23)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(853)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 87, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrimaryExpressionContext is an interface to support dynamic dispatch.
type IPrimaryExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BooleanLiteral() antlr.TerminalNode
	NumberLiteral() INumberLiteralContext
	HexLiteral() IHexLiteralContext
	StringLiteral() IStringLiteralContext
	Identifier() IIdentifierContext
	TypeKeyword() antlr.TerminalNode
	PayableKeyword() antlr.TerminalNode
	TupleExpression() ITupleExpressionContext
	TypeNameExpression() ITypeNameExpressionContext

	// IsPrimaryExpressionContext differentiates from other interfaces.
	IsPrimaryExpressionContext()
}

type PrimaryExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimaryExpressionContext() *PrimaryExpressionContext {
	var p = new(PrimaryExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_primaryExpression
	return p
}

func InitEmptyPrimaryExpressionContext(p *PrimaryExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_primaryExpression
}

func (*PrimaryExpressionContext) IsPrimaryExpressionContext() {}

func NewPrimaryExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimaryExpressionContext {
	var p = new(PrimaryExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_primaryExpression

	return p
}

func (s *PrimaryExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimaryExpressionContext) BooleanLiteral() antlr.TerminalNode {
	return s.GetToken(SolidityParserBooleanLiteral, 0)
}

func (s *PrimaryExpressionContext) NumberLiteral() INumberLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumberLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumberLiteralContext)
}

func (s *PrimaryExpressionContext) HexLiteral() IHexLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHexLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHexLiteralContext)
}

func (s *PrimaryExpressionContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *PrimaryExpressionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PrimaryExpressionContext) TypeKeyword() antlr.TerminalNode {
	return s.GetToken(SolidityParserTypeKeyword, 0)
}

func (s *PrimaryExpressionContext) PayableKeyword() antlr.TerminalNode {
	return s.GetToken(SolidityParserPayableKeyword, 0)
}

func (s *PrimaryExpressionContext) TupleExpression() ITupleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITupleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITupleExpressionContext)
}

func (s *PrimaryExpressionContext) TypeNameExpression() ITypeNameExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeNameExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeNameExpressionContext)
}

func (s *PrimaryExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrimaryExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterPrimaryExpression(s)
	}
}

func (s *PrimaryExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitPrimaryExpression(s)
	}
}

func (p *SolidityParser) PrimaryExpression() (localctx IPrimaryExpressionContext) {
	localctx = NewPrimaryExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, SolidityParserRULE_primaryExpression)
	p.SetState(871)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 90, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(854)
			p.Match(SolidityParserBooleanLiteral)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(855)
			p.NumberLiteral()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(856)
			p.HexLiteral()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(857)
			p.StringLiteral()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(858)
			p.Identifier()
		}
		p.SetState(861)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 88, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(859)
				p.Match(SolidityParserT__33)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(860)
				p.Match(SolidityParserT__34)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(863)
			p.Match(SolidityParserTypeKeyword)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(864)
			p.Match(SolidityParserPayableKeyword)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(865)
			p.TupleExpression()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(866)
			p.TypeNameExpression()
		}
		p.SetState(869)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 89, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(867)
				p.Match(SolidityParserT__33)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(868)
				p.Match(SolidityParserT__34)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpressionListContext is an interface to support dynamic dispatch.
type IExpressionListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext

	// IsExpressionListContext differentiates from other interfaces.
	IsExpressionListContext()
}

type ExpressionListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionListContext() *ExpressionListContext {
	var p = new(ExpressionListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_expressionList
	return p
}

func InitEmptyExpressionListContext(p *ExpressionListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_expressionList
}

func (*ExpressionListContext) IsExpressionListContext() {}

func NewExpressionListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionListContext {
	var p = new(ExpressionListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_expressionList

	return p
}

func (s *ExpressionListContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionListContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ExpressionListContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExpressionListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterExpressionList(s)
	}
}

func (s *ExpressionListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitExpressionList(s)
	}
}

func (p *SolidityParser) ExpressionList() (localctx IExpressionListContext) {
	localctx = NewExpressionListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, SolidityParserRULE_expressionList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(873)
		p.expression(0)
	}
	p.SetState(878)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SolidityParserT__15 {
		{
			p.SetState(874)
			p.Match(SolidityParserT__15)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(875)
			p.expression(0)
		}

		p.SetState(880)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INameValueListContext is an interface to support dynamic dispatch.
type INameValueListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllNameValue() []INameValueContext
	NameValue(i int) INameValueContext

	// IsNameValueListContext differentiates from other interfaces.
	IsNameValueListContext()
}

type NameValueListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNameValueListContext() *NameValueListContext {
	var p = new(NameValueListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_nameValueList
	return p
}

func InitEmptyNameValueListContext(p *NameValueListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_nameValueList
}

func (*NameValueListContext) IsNameValueListContext() {}

func NewNameValueListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NameValueListContext {
	var p = new(NameValueListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_nameValueList

	return p
}

func (s *NameValueListContext) GetParser() antlr.Parser { return s.parser }

func (s *NameValueListContext) AllNameValue() []INameValueContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INameValueContext); ok {
			len++
		}
	}

	tst := make([]INameValueContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INameValueContext); ok {
			tst[i] = t.(INameValueContext)
			i++
		}
	}

	return tst
}

func (s *NameValueListContext) NameValue(i int) INameValueContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameValueContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameValueContext)
}

func (s *NameValueListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NameValueListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NameValueListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterNameValueList(s)
	}
}

func (s *NameValueListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitNameValueList(s)
	}
}

func (p *SolidityParser) NameValueList() (localctx INameValueListContext) {
	localctx = NewNameValueListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, SolidityParserRULE_nameValueList)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(881)
		p.NameValue()
	}
	p.SetState(886)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 92, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(882)
				p.Match(SolidityParserT__15)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(883)
				p.NameValue()
			}

		}
		p.SetState(888)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 92, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(890)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SolidityParserT__15 {
		{
			p.SetState(889)
			p.Match(SolidityParserT__15)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INameValueContext is an interface to support dynamic dispatch.
type INameValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	Expression() IExpressionContext

	// IsNameValueContext differentiates from other interfaces.
	IsNameValueContext()
}

type NameValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNameValueContext() *NameValueContext {
	var p = new(NameValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_nameValue
	return p
}

func InitEmptyNameValueContext(p *NameValueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_nameValue
}

func (*NameValueContext) IsNameValueContext() {}

func NewNameValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NameValueContext {
	var p = new(NameValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_nameValue

	return p
}

func (s *NameValueContext) GetParser() antlr.Parser { return s.parser }

func (s *NameValueContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *NameValueContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *NameValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NameValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NameValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterNameValue(s)
	}
}

func (s *NameValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitNameValue(s)
	}
}

func (p *SolidityParser) NameValue() (localctx INameValueContext) {
	localctx = NewNameValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, SolidityParserRULE_nameValue)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(892)
		p.Identifier()
	}
	{
		p.SetState(893)
		p.Match(SolidityParserT__61)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(894)
		p.expression(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionCallArgumentsContext is an interface to support dynamic dispatch.
type IFunctionCallArgumentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NameValueList() INameValueListContext
	ExpressionList() IExpressionListContext

	// IsFunctionCallArgumentsContext differentiates from other interfaces.
	IsFunctionCallArgumentsContext()
}

type FunctionCallArgumentsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionCallArgumentsContext() *FunctionCallArgumentsContext {
	var p = new(FunctionCallArgumentsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_functionCallArguments
	return p
}

func InitEmptyFunctionCallArgumentsContext(p *FunctionCallArgumentsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_functionCallArguments
}

func (*FunctionCallArgumentsContext) IsFunctionCallArgumentsContext() {}

func NewFunctionCallArgumentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionCallArgumentsContext {
	var p = new(FunctionCallArgumentsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_functionCallArguments

	return p
}

func (s *FunctionCallArgumentsContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionCallArgumentsContext) NameValueList() INameValueListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameValueListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameValueListContext)
}

func (s *FunctionCallArgumentsContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *FunctionCallArgumentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionCallArgumentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionCallArgumentsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterFunctionCallArguments(s)
	}
}

func (s *FunctionCallArgumentsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitFunctionCallArguments(s)
	}
}

func (p *SolidityParser) FunctionCallArguments() (localctx IFunctionCallArgumentsContext) {
	localctx = NewFunctionCallArgumentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, SolidityParserRULE_functionCallArguments)
	var _la int

	p.SetState(904)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SolidityParserT__14:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(896)
			p.Match(SolidityParserT__14)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(898)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&18018796589563904) != 0) || ((int64((_la-96)) & ^0x3f) == 0 && ((int64(1)<<(_la-96))&6983778305) != 0) {
			{
				p.SetState(897)
				p.NameValueList()
			}

		}
		{
			p.SetState(900)
			p.Match(SolidityParserT__16)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SolidityParserT__4, SolidityParserT__13, SolidityParserT__22, SolidityParserT__23, SolidityParserT__24, SolidityParserT__33, SolidityParserT__35, SolidityParserT__41, SolidityParserT__53, SolidityParserT__54, SolidityParserT__55, SolidityParserT__56, SolidityParserT__57, SolidityParserT__58, SolidityParserT__59, SolidityParserT__60, SolidityParserT__62, SolidityParserT__63, SolidityParserT__64, SolidityParserT__65, SolidityParserT__66, SolidityParserT__95, SolidityParserInt, SolidityParserUint, SolidityParserByte, SolidityParserFixed, SolidityParserUfixed, SolidityParserBooleanLiteral, SolidityParserDecimalNumber, SolidityParserHexNumber, SolidityParserHexLiteralFragment, SolidityParserLeaveKeyword, SolidityParserPayableKeyword, SolidityParserTypeKeyword, SolidityParserConstructorKeyword, SolidityParserReceiveKeyword, SolidityParserIdentifier, SolidityParserStringLiteralFragment:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(902)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64((_la-5)) & ^0x3f) == 0 && ((int64(1)<<(_la-5))&9078694038950117889) != 0) || ((int64((_la-96)) & ^0x3f) == 0 && ((int64(1)<<(_la-96))&15707933693) != 0) {
			{
				p.SetState(901)
				p.ExpressionList()
			}

		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionCallContext is an interface to support dynamic dispatch.
type IFunctionCallContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext
	FunctionCallArguments() IFunctionCallArgumentsContext

	// IsFunctionCallContext differentiates from other interfaces.
	IsFunctionCallContext()
}

type FunctionCallContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionCallContext() *FunctionCallContext {
	var p = new(FunctionCallContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_functionCall
	return p
}

func InitEmptyFunctionCallContext(p *FunctionCallContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_functionCall
}

func (*FunctionCallContext) IsFunctionCallContext() {}

func NewFunctionCallContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionCallContext {
	var p = new(FunctionCallContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_functionCall

	return p
}

func (s *FunctionCallContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionCallContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *FunctionCallContext) FunctionCallArguments() IFunctionCallArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionCallArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionCallArgumentsContext)
}

func (s *FunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionCallContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterFunctionCall(s)
	}
}

func (s *FunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitFunctionCall(s)
	}
}

func (p *SolidityParser) FunctionCall() (localctx IFunctionCallContext) {
	localctx = NewFunctionCallContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, SolidityParserRULE_functionCall)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(906)
		p.expression(0)
	}
	{
		p.SetState(907)
		p.Match(SolidityParserT__22)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(908)
		p.FunctionCallArguments()
	}
	{
		p.SetState(909)
		p.Match(SolidityParserT__23)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAssemblyBlockContext is an interface to support dynamic dispatch.
type IAssemblyBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllAssemblyItem() []IAssemblyItemContext
	AssemblyItem(i int) IAssemblyItemContext

	// IsAssemblyBlockContext differentiates from other interfaces.
	IsAssemblyBlockContext()
}

type AssemblyBlockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssemblyBlockContext() *AssemblyBlockContext {
	var p = new(AssemblyBlockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_assemblyBlock
	return p
}

func InitEmptyAssemblyBlockContext(p *AssemblyBlockContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_assemblyBlock
}

func (*AssemblyBlockContext) IsAssemblyBlockContext() {}

func NewAssemblyBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssemblyBlockContext {
	var p = new(AssemblyBlockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_assemblyBlock

	return p
}

func (s *AssemblyBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *AssemblyBlockContext) AllAssemblyItem() []IAssemblyItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAssemblyItemContext); ok {
			len++
		}
	}

	tst := make([]IAssemblyItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAssemblyItemContext); ok {
			tst[i] = t.(IAssemblyItemContext)
			i++
		}
	}

	return tst
}

func (s *AssemblyBlockContext) AssemblyItem(i int) IAssemblyItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssemblyItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssemblyItemContext)
}

func (s *AssemblyBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssemblyBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssemblyBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterAssemblyBlock(s)
	}
}

func (s *AssemblyBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitAssemblyBlock(s)
	}
}

func (p *SolidityParser) AssemblyBlock() (localctx IAssemblyBlockContext) {
	localctx = NewAssemblyBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, SolidityParserRULE_assemblyBlock)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(911)
		p.Match(SolidityParserT__14)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(915)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&309072788537262080) != 0) || ((int64((_la-89)) & ^0x3f) == 0 && ((int64(1)<<(_la-89))&1993454485645) != 0) {
		{
			p.SetState(912)
			p.AssemblyItem()
		}

		p.SetState(917)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(918)
		p.Match(SolidityParserT__16)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAssemblyItemContext is an interface to support dynamic dispatch.
type IAssemblyItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	AssemblyBlock() IAssemblyBlockContext
	AssemblyExpression() IAssemblyExpressionContext
	AssemblyLocalDefinition() IAssemblyLocalDefinitionContext
	AssemblyAssignment() IAssemblyAssignmentContext
	AssemblyStackAssignment() IAssemblyStackAssignmentContext
	LabelDefinition() ILabelDefinitionContext
	AssemblySwitch() IAssemblySwitchContext
	AssemblyFunctionDefinition() IAssemblyFunctionDefinitionContext
	AssemblyFor() IAssemblyForContext
	AssemblyIf() IAssemblyIfContext
	BreakKeyword() antlr.TerminalNode
	ContinueKeyword() antlr.TerminalNode
	LeaveKeyword() antlr.TerminalNode
	SubAssembly() ISubAssemblyContext
	NumberLiteral() INumberLiteralContext
	StringLiteral() IStringLiteralContext
	HexLiteral() IHexLiteralContext

	// IsAssemblyItemContext differentiates from other interfaces.
	IsAssemblyItemContext()
}

type AssemblyItemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssemblyItemContext() *AssemblyItemContext {
	var p = new(AssemblyItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_assemblyItem
	return p
}

func InitEmptyAssemblyItemContext(p *AssemblyItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_assemblyItem
}

func (*AssemblyItemContext) IsAssemblyItemContext() {}

func NewAssemblyItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssemblyItemContext {
	var p = new(AssemblyItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_assemblyItem

	return p
}

func (s *AssemblyItemContext) GetParser() antlr.Parser { return s.parser }

func (s *AssemblyItemContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AssemblyItemContext) AssemblyBlock() IAssemblyBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssemblyBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssemblyBlockContext)
}

func (s *AssemblyItemContext) AssemblyExpression() IAssemblyExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssemblyExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssemblyExpressionContext)
}

func (s *AssemblyItemContext) AssemblyLocalDefinition() IAssemblyLocalDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssemblyLocalDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssemblyLocalDefinitionContext)
}

func (s *AssemblyItemContext) AssemblyAssignment() IAssemblyAssignmentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssemblyAssignmentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssemblyAssignmentContext)
}

func (s *AssemblyItemContext) AssemblyStackAssignment() IAssemblyStackAssignmentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssemblyStackAssignmentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssemblyStackAssignmentContext)
}

func (s *AssemblyItemContext) LabelDefinition() ILabelDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILabelDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILabelDefinitionContext)
}

func (s *AssemblyItemContext) AssemblySwitch() IAssemblySwitchContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssemblySwitchContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssemblySwitchContext)
}

func (s *AssemblyItemContext) AssemblyFunctionDefinition() IAssemblyFunctionDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssemblyFunctionDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssemblyFunctionDefinitionContext)
}

func (s *AssemblyItemContext) AssemblyFor() IAssemblyForContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssemblyForContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssemblyForContext)
}

func (s *AssemblyItemContext) AssemblyIf() IAssemblyIfContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssemblyIfContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssemblyIfContext)
}

func (s *AssemblyItemContext) BreakKeyword() antlr.TerminalNode {
	return s.GetToken(SolidityParserBreakKeyword, 0)
}

func (s *AssemblyItemContext) ContinueKeyword() antlr.TerminalNode {
	return s.GetToken(SolidityParserContinueKeyword, 0)
}

func (s *AssemblyItemContext) LeaveKeyword() antlr.TerminalNode {
	return s.GetToken(SolidityParserLeaveKeyword, 0)
}

func (s *AssemblyItemContext) SubAssembly() ISubAssemblyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubAssemblyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubAssemblyContext)
}

func (s *AssemblyItemContext) NumberLiteral() INumberLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumberLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumberLiteralContext)
}

func (s *AssemblyItemContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *AssemblyItemContext) HexLiteral() IHexLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHexLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHexLiteralContext)
}

func (s *AssemblyItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssemblyItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssemblyItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterAssemblyItem(s)
	}
}

func (s *AssemblyItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitAssemblyItem(s)
	}
}

func (p *SolidityParser) AssemblyItem() (localctx IAssemblyItemContext) {
	localctx = NewAssemblyItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, SolidityParserRULE_assemblyItem)
	p.SetState(938)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 98, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(920)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(921)
			p.AssemblyBlock()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(922)
			p.AssemblyExpression()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(923)
			p.AssemblyLocalDefinition()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(924)
			p.AssemblyAssignment()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(925)
			p.AssemblyStackAssignment()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(926)
			p.LabelDefinition()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(927)
			p.AssemblySwitch()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(928)
			p.AssemblyFunctionDefinition()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(929)
			p.AssemblyFor()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(930)
			p.AssemblyIf()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(931)
			p.Match(SolidityParserBreakKeyword)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(932)
			p.Match(SolidityParserContinueKeyword)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(933)
			p.Match(SolidityParserLeaveKeyword)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(934)
			p.SubAssembly()
		}

	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(935)
			p.NumberLiteral()
		}

	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(936)
			p.StringLiteral()
		}

	case 18:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(937)
			p.HexLiteral()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAssemblyExpressionContext is an interface to support dynamic dispatch.
type IAssemblyExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AssemblyCall() IAssemblyCallContext
	AssemblyLiteral() IAssemblyLiteralContext
	AssemblyMember() IAssemblyMemberContext

	// IsAssemblyExpressionContext differentiates from other interfaces.
	IsAssemblyExpressionContext()
}

type AssemblyExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssemblyExpressionContext() *AssemblyExpressionContext {
	var p = new(AssemblyExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_assemblyExpression
	return p
}

func InitEmptyAssemblyExpressionContext(p *AssemblyExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_assemblyExpression
}

func (*AssemblyExpressionContext) IsAssemblyExpressionContext() {}

func NewAssemblyExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssemblyExpressionContext {
	var p = new(AssemblyExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_assemblyExpression

	return p
}

func (s *AssemblyExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *AssemblyExpressionContext) AssemblyCall() IAssemblyCallContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssemblyCallContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssemblyCallContext)
}

func (s *AssemblyExpressionContext) AssemblyLiteral() IAssemblyLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssemblyLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssemblyLiteralContext)
}

func (s *AssemblyExpressionContext) AssemblyMember() IAssemblyMemberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssemblyMemberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssemblyMemberContext)
}

func (s *AssemblyExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssemblyExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssemblyExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterAssemblyExpression(s)
	}
}

func (s *AssemblyExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitAssemblyExpression(s)
	}
}

func (p *SolidityParser) AssemblyExpression() (localctx IAssemblyExpressionContext) {
	localctx = NewAssemblyExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, SolidityParserRULE_assemblyExpression)
	p.SetState(943)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 99, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(940)
			p.AssemblyCall()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(941)
			p.AssemblyLiteral()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(942)
			p.AssemblyMember()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAssemblyMemberContext is an interface to support dynamic dispatch.
type IAssemblyMemberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext

	// IsAssemblyMemberContext differentiates from other interfaces.
	IsAssemblyMemberContext()
}

type AssemblyMemberContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssemblyMemberContext() *AssemblyMemberContext {
	var p = new(AssemblyMemberContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_assemblyMember
	return p
}

func InitEmptyAssemblyMemberContext(p *AssemblyMemberContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_assemblyMember
}

func (*AssemblyMemberContext) IsAssemblyMemberContext() {}

func NewAssemblyMemberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssemblyMemberContext {
	var p = new(AssemblyMemberContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_assemblyMember

	return p
}

func (s *AssemblyMemberContext) GetParser() antlr.Parser { return s.parser }

func (s *AssemblyMemberContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *AssemblyMemberContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AssemblyMemberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssemblyMemberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssemblyMemberContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterAssemblyMember(s)
	}
}

func (s *AssemblyMemberContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitAssemblyMember(s)
	}
}

func (p *SolidityParser) AssemblyMember() (localctx IAssemblyMemberContext) {
	localctx = NewAssemblyMemberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, SolidityParserRULE_assemblyMember)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(945)
		p.Identifier()
	}
	{
		p.SetState(946)
		p.Match(SolidityParserT__36)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(947)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAssemblyCallContext is an interface to support dynamic dispatch.
type IAssemblyCallContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	AllAssemblyExpression() []IAssemblyExpressionContext
	AssemblyExpression(i int) IAssemblyExpressionContext

	// IsAssemblyCallContext differentiates from other interfaces.
	IsAssemblyCallContext()
}

type AssemblyCallContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssemblyCallContext() *AssemblyCallContext {
	var p = new(AssemblyCallContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_assemblyCall
	return p
}

func InitEmptyAssemblyCallContext(p *AssemblyCallContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_assemblyCall
}

func (*AssemblyCallContext) IsAssemblyCallContext() {}

func NewAssemblyCallContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssemblyCallContext {
	var p = new(AssemblyCallContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_assemblyCall

	return p
}

func (s *AssemblyCallContext) GetParser() antlr.Parser { return s.parser }

func (s *AssemblyCallContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AssemblyCallContext) AllAssemblyExpression() []IAssemblyExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAssemblyExpressionContext); ok {
			len++
		}
	}

	tst := make([]IAssemblyExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAssemblyExpressionContext); ok {
			tst[i] = t.(IAssemblyExpressionContext)
			i++
		}
	}

	return tst
}

func (s *AssemblyCallContext) AssemblyExpression(i int) IAssemblyExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssemblyExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssemblyExpressionContext)
}

func (s *AssemblyCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssemblyCallContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssemblyCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterAssemblyCall(s)
	}
}

func (s *AssemblyCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitAssemblyCall(s)
	}
}

func (p *SolidityParser) AssemblyCall() (localctx IAssemblyCallContext) {
	localctx = NewAssemblyCallContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, SolidityParserRULE_assemblyCall)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(953)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SolidityParserT__50:
		{
			p.SetState(949)
			p.Match(SolidityParserT__50)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SolidityParserT__35:
		{
			p.SetState(950)
			p.Match(SolidityParserT__35)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SolidityParserT__57:
		{
			p.SetState(951)
			p.Match(SolidityParserT__57)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SolidityParserT__13, SolidityParserT__24, SolidityParserT__41, SolidityParserT__53, SolidityParserT__95, SolidityParserLeaveKeyword, SolidityParserPayableKeyword, SolidityParserConstructorKeyword, SolidityParserReceiveKeyword, SolidityParserIdentifier:
		{
			p.SetState(952)
			p.Identifier()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(967)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 103, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(955)
			p.Match(SolidityParserT__22)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(957)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&308501041274437632) != 0) || ((int64((_la-96)) & ^0x3f) == 0 && ((int64(1)<<(_la-96))&15573715713) != 0) {
			{
				p.SetState(956)
				p.AssemblyExpression()
			}

		}
		p.SetState(963)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == SolidityParserT__15 {
			{
				p.SetState(959)
				p.Match(SolidityParserT__15)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(960)
				p.AssemblyExpression()
			}

			p.SetState(965)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(966)
			p.Match(SolidityParserT__23)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAssemblyLocalDefinitionContext is an interface to support dynamic dispatch.
type IAssemblyLocalDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AssemblyIdentifierOrList() IAssemblyIdentifierOrListContext
	AssemblyExpression() IAssemblyExpressionContext

	// IsAssemblyLocalDefinitionContext differentiates from other interfaces.
	IsAssemblyLocalDefinitionContext()
}

type AssemblyLocalDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssemblyLocalDefinitionContext() *AssemblyLocalDefinitionContext {
	var p = new(AssemblyLocalDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_assemblyLocalDefinition
	return p
}

func InitEmptyAssemblyLocalDefinitionContext(p *AssemblyLocalDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_assemblyLocalDefinition
}

func (*AssemblyLocalDefinitionContext) IsAssemblyLocalDefinitionContext() {}

func NewAssemblyLocalDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssemblyLocalDefinitionContext {
	var p = new(AssemblyLocalDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_assemblyLocalDefinition

	return p
}

func (s *AssemblyLocalDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *AssemblyLocalDefinitionContext) AssemblyIdentifierOrList() IAssemblyIdentifierOrListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssemblyIdentifierOrListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssemblyIdentifierOrListContext)
}

func (s *AssemblyLocalDefinitionContext) AssemblyExpression() IAssemblyExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssemblyExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssemblyExpressionContext)
}

func (s *AssemblyLocalDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssemblyLocalDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssemblyLocalDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterAssemblyLocalDefinition(s)
	}
}

func (s *AssemblyLocalDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitAssemblyLocalDefinition(s)
	}
}

func (p *SolidityParser) AssemblyLocalDefinition() (localctx IAssemblyLocalDefinitionContext) {
	localctx = NewAssemblyLocalDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, SolidityParserRULE_assemblyLocalDefinition)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(969)
		p.Match(SolidityParserT__88)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(970)
		p.AssemblyIdentifierOrList()
	}
	p.SetState(973)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SolidityParserT__89 {
		{
			p.SetState(971)
			p.Match(SolidityParserT__89)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(972)
			p.AssemblyExpression()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAssemblyAssignmentContext is an interface to support dynamic dispatch.
type IAssemblyAssignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AssemblyIdentifierOrList() IAssemblyIdentifierOrListContext
	AssemblyExpression() IAssemblyExpressionContext

	// IsAssemblyAssignmentContext differentiates from other interfaces.
	IsAssemblyAssignmentContext()
}

type AssemblyAssignmentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssemblyAssignmentContext() *AssemblyAssignmentContext {
	var p = new(AssemblyAssignmentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_assemblyAssignment
	return p
}

func InitEmptyAssemblyAssignmentContext(p *AssemblyAssignmentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_assemblyAssignment
}

func (*AssemblyAssignmentContext) IsAssemblyAssignmentContext() {}

func NewAssemblyAssignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssemblyAssignmentContext {
	var p = new(AssemblyAssignmentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_assemblyAssignment

	return p
}

func (s *AssemblyAssignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *AssemblyAssignmentContext) AssemblyIdentifierOrList() IAssemblyIdentifierOrListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssemblyIdentifierOrListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssemblyIdentifierOrListContext)
}

func (s *AssemblyAssignmentContext) AssemblyExpression() IAssemblyExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssemblyExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssemblyExpressionContext)
}

func (s *AssemblyAssignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssemblyAssignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssemblyAssignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterAssemblyAssignment(s)
	}
}

func (s *AssemblyAssignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitAssemblyAssignment(s)
	}
}

func (p *SolidityParser) AssemblyAssignment() (localctx IAssemblyAssignmentContext) {
	localctx = NewAssemblyAssignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, SolidityParserRULE_assemblyAssignment)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(975)
		p.AssemblyIdentifierOrList()
	}
	{
		p.SetState(976)
		p.Match(SolidityParserT__89)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(977)
		p.AssemblyExpression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAssemblyIdentifierOrListContext is an interface to support dynamic dispatch.
type IAssemblyIdentifierOrListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	AssemblyMember() IAssemblyMemberContext
	AssemblyIdentifierList() IAssemblyIdentifierListContext

	// IsAssemblyIdentifierOrListContext differentiates from other interfaces.
	IsAssemblyIdentifierOrListContext()
}

type AssemblyIdentifierOrListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssemblyIdentifierOrListContext() *AssemblyIdentifierOrListContext {
	var p = new(AssemblyIdentifierOrListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_assemblyIdentifierOrList
	return p
}

func InitEmptyAssemblyIdentifierOrListContext(p *AssemblyIdentifierOrListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_assemblyIdentifierOrList
}

func (*AssemblyIdentifierOrListContext) IsAssemblyIdentifierOrListContext() {}

func NewAssemblyIdentifierOrListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssemblyIdentifierOrListContext {
	var p = new(AssemblyIdentifierOrListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_assemblyIdentifierOrList

	return p
}

func (s *AssemblyIdentifierOrListContext) GetParser() antlr.Parser { return s.parser }

func (s *AssemblyIdentifierOrListContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AssemblyIdentifierOrListContext) AssemblyMember() IAssemblyMemberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssemblyMemberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssemblyMemberContext)
}

func (s *AssemblyIdentifierOrListContext) AssemblyIdentifierList() IAssemblyIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssemblyIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssemblyIdentifierListContext)
}

func (s *AssemblyIdentifierOrListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssemblyIdentifierOrListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssemblyIdentifierOrListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterAssemblyIdentifierOrList(s)
	}
}

func (s *AssemblyIdentifierOrListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitAssemblyIdentifierOrList(s)
	}
}

func (p *SolidityParser) AssemblyIdentifierOrList() (localctx IAssemblyIdentifierOrListContext) {
	localctx = NewAssemblyIdentifierOrListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, SolidityParserRULE_assemblyIdentifierOrList)
	p.SetState(985)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 105, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(979)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(980)
			p.AssemblyMember()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(981)
			p.Match(SolidityParserT__22)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(982)
			p.AssemblyIdentifierList()
		}
		{
			p.SetState(983)
			p.Match(SolidityParserT__23)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAssemblyIdentifierListContext is an interface to support dynamic dispatch.
type IAssemblyIdentifierListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext

	// IsAssemblyIdentifierListContext differentiates from other interfaces.
	IsAssemblyIdentifierListContext()
}

type AssemblyIdentifierListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssemblyIdentifierListContext() *AssemblyIdentifierListContext {
	var p = new(AssemblyIdentifierListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_assemblyIdentifierList
	return p
}

func InitEmptyAssemblyIdentifierListContext(p *AssemblyIdentifierListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_assemblyIdentifierList
}

func (*AssemblyIdentifierListContext) IsAssemblyIdentifierListContext() {}

func NewAssemblyIdentifierListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssemblyIdentifierListContext {
	var p = new(AssemblyIdentifierListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_assemblyIdentifierList

	return p
}

func (s *AssemblyIdentifierListContext) GetParser() antlr.Parser { return s.parser }

func (s *AssemblyIdentifierListContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *AssemblyIdentifierListContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AssemblyIdentifierListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssemblyIdentifierListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssemblyIdentifierListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterAssemblyIdentifierList(s)
	}
}

func (s *AssemblyIdentifierListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitAssemblyIdentifierList(s)
	}
}

func (p *SolidityParser) AssemblyIdentifierList() (localctx IAssemblyIdentifierListContext) {
	localctx = NewAssemblyIdentifierListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, SolidityParserRULE_assemblyIdentifierList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(987)
		p.Identifier()
	}
	p.SetState(992)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SolidityParserT__15 {
		{
			p.SetState(988)
			p.Match(SolidityParserT__15)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(989)
			p.Identifier()
		}

		p.SetState(994)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAssemblyStackAssignmentContext is an interface to support dynamic dispatch.
type IAssemblyStackAssignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext

	// IsAssemblyStackAssignmentContext differentiates from other interfaces.
	IsAssemblyStackAssignmentContext()
}

type AssemblyStackAssignmentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssemblyStackAssignmentContext() *AssemblyStackAssignmentContext {
	var p = new(AssemblyStackAssignmentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_assemblyStackAssignment
	return p
}

func InitEmptyAssemblyStackAssignmentContext(p *AssemblyStackAssignmentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_assemblyStackAssignment
}

func (*AssemblyStackAssignmentContext) IsAssemblyStackAssignmentContext() {}

func NewAssemblyStackAssignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssemblyStackAssignmentContext {
	var p = new(AssemblyStackAssignmentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_assemblyStackAssignment

	return p
}

func (s *AssemblyStackAssignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *AssemblyStackAssignmentContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AssemblyStackAssignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssemblyStackAssignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssemblyStackAssignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterAssemblyStackAssignment(s)
	}
}

func (s *AssemblyStackAssignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitAssemblyStackAssignment(s)
	}
}

func (p *SolidityParser) AssemblyStackAssignment() (localctx IAssemblyStackAssignmentContext) {
	localctx = NewAssemblyStackAssignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, SolidityParserRULE_assemblyStackAssignment)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(995)
		p.Match(SolidityParserT__90)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(996)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILabelDefinitionContext is an interface to support dynamic dispatch.
type ILabelDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext

	// IsLabelDefinitionContext differentiates from other interfaces.
	IsLabelDefinitionContext()
}

type LabelDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLabelDefinitionContext() *LabelDefinitionContext {
	var p = new(LabelDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_labelDefinition
	return p
}

func InitEmptyLabelDefinitionContext(p *LabelDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_labelDefinition
}

func (*LabelDefinitionContext) IsLabelDefinitionContext() {}

func NewLabelDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LabelDefinitionContext {
	var p = new(LabelDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_labelDefinition

	return p
}

func (s *LabelDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *LabelDefinitionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *LabelDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LabelDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterLabelDefinition(s)
	}
}

func (s *LabelDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitLabelDefinition(s)
	}
}

func (p *SolidityParser) LabelDefinition() (localctx ILabelDefinitionContext) {
	localctx = NewLabelDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, SolidityParserRULE_labelDefinition)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(998)
		p.Identifier()
	}
	{
		p.SetState(999)
		p.Match(SolidityParserT__61)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAssemblySwitchContext is an interface to support dynamic dispatch.
type IAssemblySwitchContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AssemblyExpression() IAssemblyExpressionContext
	AllAssemblyCase() []IAssemblyCaseContext
	AssemblyCase(i int) IAssemblyCaseContext

	// IsAssemblySwitchContext differentiates from other interfaces.
	IsAssemblySwitchContext()
}

type AssemblySwitchContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssemblySwitchContext() *AssemblySwitchContext {
	var p = new(AssemblySwitchContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_assemblySwitch
	return p
}

func InitEmptyAssemblySwitchContext(p *AssemblySwitchContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_assemblySwitch
}

func (*AssemblySwitchContext) IsAssemblySwitchContext() {}

func NewAssemblySwitchContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssemblySwitchContext {
	var p = new(AssemblySwitchContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_assemblySwitch

	return p
}

func (s *AssemblySwitchContext) GetParser() antlr.Parser { return s.parser }

func (s *AssemblySwitchContext) AssemblyExpression() IAssemblyExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssemblyExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssemblyExpressionContext)
}

func (s *AssemblySwitchContext) AllAssemblyCase() []IAssemblyCaseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAssemblyCaseContext); ok {
			len++
		}
	}

	tst := make([]IAssemblyCaseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAssemblyCaseContext); ok {
			tst[i] = t.(IAssemblyCaseContext)
			i++
		}
	}

	return tst
}

func (s *AssemblySwitchContext) AssemblyCase(i int) IAssemblyCaseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssemblyCaseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssemblyCaseContext)
}

func (s *AssemblySwitchContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssemblySwitchContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssemblySwitchContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterAssemblySwitch(s)
	}
}

func (s *AssemblySwitchContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitAssemblySwitch(s)
	}
}

func (p *SolidityParser) AssemblySwitch() (localctx IAssemblySwitchContext) {
	localctx = NewAssemblySwitchContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, SolidityParserRULE_assemblySwitch)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1001)
		p.Match(SolidityParserT__91)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1002)
		p.AssemblyExpression()
	}
	p.SetState(1006)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SolidityParserT__92 || _la == SolidityParserT__93 {
		{
			p.SetState(1003)
			p.AssemblyCase()
		}

		p.SetState(1008)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAssemblyCaseContext is an interface to support dynamic dispatch.
type IAssemblyCaseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AssemblyLiteral() IAssemblyLiteralContext
	AssemblyBlock() IAssemblyBlockContext

	// IsAssemblyCaseContext differentiates from other interfaces.
	IsAssemblyCaseContext()
}

type AssemblyCaseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssemblyCaseContext() *AssemblyCaseContext {
	var p = new(AssemblyCaseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_assemblyCase
	return p
}

func InitEmptyAssemblyCaseContext(p *AssemblyCaseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_assemblyCase
}

func (*AssemblyCaseContext) IsAssemblyCaseContext() {}

func NewAssemblyCaseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssemblyCaseContext {
	var p = new(AssemblyCaseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_assemblyCase

	return p
}

func (s *AssemblyCaseContext) GetParser() antlr.Parser { return s.parser }

func (s *AssemblyCaseContext) AssemblyLiteral() IAssemblyLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssemblyLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssemblyLiteralContext)
}

func (s *AssemblyCaseContext) AssemblyBlock() IAssemblyBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssemblyBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssemblyBlockContext)
}

func (s *AssemblyCaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssemblyCaseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssemblyCaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterAssemblyCase(s)
	}
}

func (s *AssemblyCaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitAssemblyCase(s)
	}
}

func (p *SolidityParser) AssemblyCase() (localctx IAssemblyCaseContext) {
	localctx = NewAssemblyCaseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, SolidityParserRULE_assemblyCase)
	p.SetState(1015)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SolidityParserT__92:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1009)
			p.Match(SolidityParserT__92)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1010)
			p.AssemblyLiteral()
		}
		{
			p.SetState(1011)
			p.AssemblyBlock()
		}

	case SolidityParserT__93:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1013)
			p.Match(SolidityParserT__93)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1014)
			p.AssemblyBlock()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAssemblyFunctionDefinitionContext is an interface to support dynamic dispatch.
type IAssemblyFunctionDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	AssemblyBlock() IAssemblyBlockContext
	AssemblyIdentifierList() IAssemblyIdentifierListContext
	AssemblyFunctionReturns() IAssemblyFunctionReturnsContext

	// IsAssemblyFunctionDefinitionContext differentiates from other interfaces.
	IsAssemblyFunctionDefinitionContext()
}

type AssemblyFunctionDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssemblyFunctionDefinitionContext() *AssemblyFunctionDefinitionContext {
	var p = new(AssemblyFunctionDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_assemblyFunctionDefinition
	return p
}

func InitEmptyAssemblyFunctionDefinitionContext(p *AssemblyFunctionDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_assemblyFunctionDefinition
}

func (*AssemblyFunctionDefinitionContext) IsAssemblyFunctionDefinitionContext() {}

func NewAssemblyFunctionDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssemblyFunctionDefinitionContext {
	var p = new(AssemblyFunctionDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_assemblyFunctionDefinition

	return p
}

func (s *AssemblyFunctionDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *AssemblyFunctionDefinitionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AssemblyFunctionDefinitionContext) AssemblyBlock() IAssemblyBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssemblyBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssemblyBlockContext)
}

func (s *AssemblyFunctionDefinitionContext) AssemblyIdentifierList() IAssemblyIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssemblyIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssemblyIdentifierListContext)
}

func (s *AssemblyFunctionDefinitionContext) AssemblyFunctionReturns() IAssemblyFunctionReturnsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssemblyFunctionReturnsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssemblyFunctionReturnsContext)
}

func (s *AssemblyFunctionDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssemblyFunctionDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssemblyFunctionDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterAssemblyFunctionDefinition(s)
	}
}

func (s *AssemblyFunctionDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitAssemblyFunctionDefinition(s)
	}
}

func (p *SolidityParser) AssemblyFunctionDefinition() (localctx IAssemblyFunctionDefinitionContext) {
	localctx = NewAssemblyFunctionDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, SolidityParserRULE_assemblyFunctionDefinition)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1017)
		p.Match(SolidityParserT__29)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1018)
		p.Identifier()
	}
	{
		p.SetState(1019)
		p.Match(SolidityParserT__22)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1021)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&18018796589563904) != 0) || ((int64((_la-96)) & ^0x3f) == 0 && ((int64(1)<<(_la-96))&6983778305) != 0) {
		{
			p.SetState(1020)
			p.AssemblyIdentifierList()
		}

	}
	{
		p.SetState(1023)
		p.Match(SolidityParserT__23)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1025)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SolidityParserT__94 {
		{
			p.SetState(1024)
			p.AssemblyFunctionReturns()
		}

	}
	{
		p.SetState(1027)
		p.AssemblyBlock()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAssemblyFunctionReturnsContext is an interface to support dynamic dispatch.
type IAssemblyFunctionReturnsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AssemblyIdentifierList() IAssemblyIdentifierListContext

	// IsAssemblyFunctionReturnsContext differentiates from other interfaces.
	IsAssemblyFunctionReturnsContext()
}

type AssemblyFunctionReturnsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssemblyFunctionReturnsContext() *AssemblyFunctionReturnsContext {
	var p = new(AssemblyFunctionReturnsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_assemblyFunctionReturns
	return p
}

func InitEmptyAssemblyFunctionReturnsContext(p *AssemblyFunctionReturnsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_assemblyFunctionReturns
}

func (*AssemblyFunctionReturnsContext) IsAssemblyFunctionReturnsContext() {}

func NewAssemblyFunctionReturnsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssemblyFunctionReturnsContext {
	var p = new(AssemblyFunctionReturnsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_assemblyFunctionReturns

	return p
}

func (s *AssemblyFunctionReturnsContext) GetParser() antlr.Parser { return s.parser }

func (s *AssemblyFunctionReturnsContext) AssemblyIdentifierList() IAssemblyIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssemblyIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssemblyIdentifierListContext)
}

func (s *AssemblyFunctionReturnsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssemblyFunctionReturnsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssemblyFunctionReturnsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterAssemblyFunctionReturns(s)
	}
}

func (s *AssemblyFunctionReturnsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitAssemblyFunctionReturns(s)
	}
}

func (p *SolidityParser) AssemblyFunctionReturns() (localctx IAssemblyFunctionReturnsContext) {
	localctx = NewAssemblyFunctionReturnsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, SolidityParserRULE_assemblyFunctionReturns)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1029)
		p.Match(SolidityParserT__94)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1030)
		p.AssemblyIdentifierList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAssemblyForContext is an interface to support dynamic dispatch.
type IAssemblyForContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllAssemblyExpression() []IAssemblyExpressionContext
	AssemblyExpression(i int) IAssemblyExpressionContext
	AllAssemblyBlock() []IAssemblyBlockContext
	AssemblyBlock(i int) IAssemblyBlockContext

	// IsAssemblyForContext differentiates from other interfaces.
	IsAssemblyForContext()
}

type AssemblyForContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssemblyForContext() *AssemblyForContext {
	var p = new(AssemblyForContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_assemblyFor
	return p
}

func InitEmptyAssemblyForContext(p *AssemblyForContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_assemblyFor
}

func (*AssemblyForContext) IsAssemblyForContext() {}

func NewAssemblyForContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssemblyForContext {
	var p = new(AssemblyForContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_assemblyFor

	return p
}

func (s *AssemblyForContext) GetParser() antlr.Parser { return s.parser }

func (s *AssemblyForContext) AllAssemblyExpression() []IAssemblyExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAssemblyExpressionContext); ok {
			len++
		}
	}

	tst := make([]IAssemblyExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAssemblyExpressionContext); ok {
			tst[i] = t.(IAssemblyExpressionContext)
			i++
		}
	}

	return tst
}

func (s *AssemblyForContext) AssemblyExpression(i int) IAssemblyExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssemblyExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssemblyExpressionContext)
}

func (s *AssemblyForContext) AllAssemblyBlock() []IAssemblyBlockContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAssemblyBlockContext); ok {
			len++
		}
	}

	tst := make([]IAssemblyBlockContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAssemblyBlockContext); ok {
			tst[i] = t.(IAssemblyBlockContext)
			i++
		}
	}

	return tst
}

func (s *AssemblyForContext) AssemblyBlock(i int) IAssemblyBlockContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssemblyBlockContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssemblyBlockContext)
}

func (s *AssemblyForContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssemblyForContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssemblyForContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterAssemblyFor(s)
	}
}

func (s *AssemblyForContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitAssemblyFor(s)
	}
}

func (p *SolidityParser) AssemblyFor() (localctx IAssemblyForContext) {
	localctx = NewAssemblyForContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, SolidityParserRULE_assemblyFor)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1032)
		p.Match(SolidityParserT__26)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1035)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SolidityParserT__14:
		{
			p.SetState(1033)
			p.AssemblyBlock()
		}

	case SolidityParserT__13, SolidityParserT__24, SolidityParserT__35, SolidityParserT__41, SolidityParserT__50, SolidityParserT__53, SolidityParserT__57, SolidityParserT__95, SolidityParserDecimalNumber, SolidityParserHexNumber, SolidityParserHexLiteralFragment, SolidityParserLeaveKeyword, SolidityParserPayableKeyword, SolidityParserConstructorKeyword, SolidityParserReceiveKeyword, SolidityParserIdentifier, SolidityParserStringLiteralFragment:
		{
			p.SetState(1034)
			p.AssemblyExpression()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	{
		p.SetState(1037)
		p.AssemblyExpression()
	}
	p.SetState(1040)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SolidityParserT__14:
		{
			p.SetState(1038)
			p.AssemblyBlock()
		}

	case SolidityParserT__13, SolidityParserT__24, SolidityParserT__35, SolidityParserT__41, SolidityParserT__50, SolidityParserT__53, SolidityParserT__57, SolidityParserT__95, SolidityParserDecimalNumber, SolidityParserHexNumber, SolidityParserHexLiteralFragment, SolidityParserLeaveKeyword, SolidityParserPayableKeyword, SolidityParserConstructorKeyword, SolidityParserReceiveKeyword, SolidityParserIdentifier, SolidityParserStringLiteralFragment:
		{
			p.SetState(1039)
			p.AssemblyExpression()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	{
		p.SetState(1042)
		p.AssemblyBlock()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAssemblyIfContext is an interface to support dynamic dispatch.
type IAssemblyIfContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AssemblyExpression() IAssemblyExpressionContext
	AssemblyBlock() IAssemblyBlockContext

	// IsAssemblyIfContext differentiates from other interfaces.
	IsAssemblyIfContext()
}

type AssemblyIfContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssemblyIfContext() *AssemblyIfContext {
	var p = new(AssemblyIfContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_assemblyIf
	return p
}

func InitEmptyAssemblyIfContext(p *AssemblyIfContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_assemblyIf
}

func (*AssemblyIfContext) IsAssemblyIfContext() {}

func NewAssemblyIfContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssemblyIfContext {
	var p = new(AssemblyIfContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_assemblyIf

	return p
}

func (s *AssemblyIfContext) GetParser() antlr.Parser { return s.parser }

func (s *AssemblyIfContext) AssemblyExpression() IAssemblyExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssemblyExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssemblyExpressionContext)
}

func (s *AssemblyIfContext) AssemblyBlock() IAssemblyBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssemblyBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssemblyBlockContext)
}

func (s *AssemblyIfContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssemblyIfContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssemblyIfContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterAssemblyIf(s)
	}
}

func (s *AssemblyIfContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitAssemblyIf(s)
	}
}

func (p *SolidityParser) AssemblyIf() (localctx IAssemblyIfContext) {
	localctx = NewAssemblyIfContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, SolidityParserRULE_assemblyIf)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1044)
		p.Match(SolidityParserT__42)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1045)
		p.AssemblyExpression()
	}
	{
		p.SetState(1046)
		p.AssemblyBlock()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAssemblyLiteralContext is an interface to support dynamic dispatch.
type IAssemblyLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	StringLiteral() IStringLiteralContext
	DecimalNumber() antlr.TerminalNode
	HexNumber() antlr.TerminalNode
	HexLiteral() IHexLiteralContext

	// IsAssemblyLiteralContext differentiates from other interfaces.
	IsAssemblyLiteralContext()
}

type AssemblyLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssemblyLiteralContext() *AssemblyLiteralContext {
	var p = new(AssemblyLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_assemblyLiteral
	return p
}

func InitEmptyAssemblyLiteralContext(p *AssemblyLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_assemblyLiteral
}

func (*AssemblyLiteralContext) IsAssemblyLiteralContext() {}

func NewAssemblyLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssemblyLiteralContext {
	var p = new(AssemblyLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_assemblyLiteral

	return p
}

func (s *AssemblyLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *AssemblyLiteralContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *AssemblyLiteralContext) DecimalNumber() antlr.TerminalNode {
	return s.GetToken(SolidityParserDecimalNumber, 0)
}

func (s *AssemblyLiteralContext) HexNumber() antlr.TerminalNode {
	return s.GetToken(SolidityParserHexNumber, 0)
}

func (s *AssemblyLiteralContext) HexLiteral() IHexLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHexLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHexLiteralContext)
}

func (s *AssemblyLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssemblyLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssemblyLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterAssemblyLiteral(s)
	}
}

func (s *AssemblyLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitAssemblyLiteral(s)
	}
}

func (p *SolidityParser) AssemblyLiteral() (localctx IAssemblyLiteralContext) {
	localctx = NewAssemblyLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, SolidityParserRULE_assemblyLiteral)
	p.SetState(1052)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SolidityParserStringLiteralFragment:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1048)
			p.StringLiteral()
		}

	case SolidityParserDecimalNumber:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1049)
			p.Match(SolidityParserDecimalNumber)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SolidityParserHexNumber:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1050)
			p.Match(SolidityParserHexNumber)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SolidityParserHexLiteralFragment:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1051)
			p.HexLiteral()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISubAssemblyContext is an interface to support dynamic dispatch.
type ISubAssemblyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	AssemblyBlock() IAssemblyBlockContext

	// IsSubAssemblyContext differentiates from other interfaces.
	IsSubAssemblyContext()
}

type SubAssemblyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubAssemblyContext() *SubAssemblyContext {
	var p = new(SubAssemblyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_subAssembly
	return p
}

func InitEmptySubAssemblyContext(p *SubAssemblyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_subAssembly
}

func (*SubAssemblyContext) IsSubAssemblyContext() {}

func NewSubAssemblyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubAssemblyContext {
	var p = new(SubAssemblyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_subAssembly

	return p
}

func (s *SubAssemblyContext) GetParser() antlr.Parser { return s.parser }

func (s *SubAssemblyContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SubAssemblyContext) AssemblyBlock() IAssemblyBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssemblyBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssemblyBlockContext)
}

func (s *SubAssemblyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubAssemblyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubAssemblyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterSubAssembly(s)
	}
}

func (s *SubAssemblyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitSubAssembly(s)
	}
}

func (p *SolidityParser) SubAssembly() (localctx ISubAssemblyContext) {
	localctx = NewSubAssemblyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, SolidityParserRULE_subAssembly)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1054)
		p.Match(SolidityParserT__48)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1055)
		p.Identifier()
	}
	{
		p.SetState(1056)
		p.AssemblyBlock()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITupleExpressionContext is an interface to support dynamic dispatch.
type ITupleExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext

	// IsTupleExpressionContext differentiates from other interfaces.
	IsTupleExpressionContext()
}

type TupleExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTupleExpressionContext() *TupleExpressionContext {
	var p = new(TupleExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_tupleExpression
	return p
}

func InitEmptyTupleExpressionContext(p *TupleExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_tupleExpression
}

func (*TupleExpressionContext) IsTupleExpressionContext() {}

func NewTupleExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TupleExpressionContext {
	var p = new(TupleExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_tupleExpression

	return p
}

func (s *TupleExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *TupleExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *TupleExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *TupleExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TupleExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TupleExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterTupleExpression(s)
	}
}

func (s *TupleExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitTupleExpression(s)
	}
}

func (p *SolidityParser) TupleExpression() (localctx ITupleExpressionContext) {
	localctx = NewTupleExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, SolidityParserRULE_tupleExpression)
	var _la int

	p.SetState(1084)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SolidityParserT__22:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1058)
			p.Match(SolidityParserT__22)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(1060)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64((_la-5)) & ^0x3f) == 0 && ((int64(1)<<(_la-5))&9078694038950117889) != 0) || ((int64((_la-96)) & ^0x3f) == 0 && ((int64(1)<<(_la-96))&15707933693) != 0) {
			{
				p.SetState(1059)
				p.expression(0)
			}

		}
		p.SetState(1068)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == SolidityParserT__15 {
			{
				p.SetState(1062)
				p.Match(SolidityParserT__15)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(1064)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if ((int64((_la-5)) & ^0x3f) == 0 && ((int64(1)<<(_la-5))&9078694038950117889) != 0) || ((int64((_la-96)) & ^0x3f) == 0 && ((int64(1)<<(_la-96))&15707933693) != 0) {
				{
					p.SetState(1063)
					p.expression(0)
				}

			}

			p.SetState(1070)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

		{
			p.SetState(1071)
			p.Match(SolidityParserT__23)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SolidityParserT__33:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1072)
			p.Match(SolidityParserT__33)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1081)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64((_la-5)) & ^0x3f) == 0 && ((int64(1)<<(_la-5))&9078694038950117889) != 0) || ((int64((_la-96)) & ^0x3f) == 0 && ((int64(1)<<(_la-96))&15707933693) != 0) {
			{
				p.SetState(1073)
				p.expression(0)
			}
			p.SetState(1078)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == SolidityParserT__15 {
				{
					p.SetState(1074)
					p.Match(SolidityParserT__15)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1075)
					p.expression(0)
				}

				p.SetState(1080)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(1083)
			p.Match(SolidityParserT__34)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeNameExpressionContext is an interface to support dynamic dispatch.
type ITypeNameExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ElementaryTypeName() IElementaryTypeNameContext
	UserDefinedTypeName() IUserDefinedTypeNameContext

	// IsTypeNameExpressionContext differentiates from other interfaces.
	IsTypeNameExpressionContext()
}

type TypeNameExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeNameExpressionContext() *TypeNameExpressionContext {
	var p = new(TypeNameExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_typeNameExpression
	return p
}

func InitEmptyTypeNameExpressionContext(p *TypeNameExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_typeNameExpression
}

func (*TypeNameExpressionContext) IsTypeNameExpressionContext() {}

func NewTypeNameExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeNameExpressionContext {
	var p = new(TypeNameExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_typeNameExpression

	return p
}

func (s *TypeNameExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeNameExpressionContext) ElementaryTypeName() IElementaryTypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementaryTypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementaryTypeNameContext)
}

func (s *TypeNameExpressionContext) UserDefinedTypeName() IUserDefinedTypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserDefinedTypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserDefinedTypeNameContext)
}

func (s *TypeNameExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeNameExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeNameExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterTypeNameExpression(s)
	}
}

func (s *TypeNameExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitTypeNameExpression(s)
	}
}

func (p *SolidityParser) TypeNameExpression() (localctx ITypeNameExpressionContext) {
	localctx = NewTypeNameExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, SolidityParserRULE_typeNameExpression)
	p.SetState(1088)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SolidityParserT__35, SolidityParserT__54, SolidityParserT__55, SolidityParserT__56, SolidityParserT__57, SolidityParserInt, SolidityParserUint, SolidityParserByte, SolidityParserFixed, SolidityParserUfixed:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1086)
			p.ElementaryTypeName()
		}

	case SolidityParserT__13, SolidityParserT__24, SolidityParserT__41, SolidityParserT__53, SolidityParserT__95, SolidityParserLeaveKeyword, SolidityParserPayableKeyword, SolidityParserConstructorKeyword, SolidityParserReceiveKeyword, SolidityParserIdentifier:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1087)
			p.UserDefinedTypeName()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INumberLiteralContext is an interface to support dynamic dispatch.
type INumberLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DecimalNumber() antlr.TerminalNode
	HexNumber() antlr.TerminalNode
	NumberUnit() antlr.TerminalNode

	// IsNumberLiteralContext differentiates from other interfaces.
	IsNumberLiteralContext()
}

type NumberLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNumberLiteralContext() *NumberLiteralContext {
	var p = new(NumberLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_numberLiteral
	return p
}

func InitEmptyNumberLiteralContext(p *NumberLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_numberLiteral
}

func (*NumberLiteralContext) IsNumberLiteralContext() {}

func NewNumberLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NumberLiteralContext {
	var p = new(NumberLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_numberLiteral

	return p
}

func (s *NumberLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *NumberLiteralContext) DecimalNumber() antlr.TerminalNode {
	return s.GetToken(SolidityParserDecimalNumber, 0)
}

func (s *NumberLiteralContext) HexNumber() antlr.TerminalNode {
	return s.GetToken(SolidityParserHexNumber, 0)
}

func (s *NumberLiteralContext) NumberUnit() antlr.TerminalNode {
	return s.GetToken(SolidityParserNumberUnit, 0)
}

func (s *NumberLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumberLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NumberLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterNumberLiteral(s)
	}
}

func (s *NumberLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitNumberLiteral(s)
	}
}

func (p *SolidityParser) NumberLiteral() (localctx INumberLiteralContext) {
	localctx = NewNumberLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, SolidityParserRULE_numberLiteral)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1090)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SolidityParserDecimalNumber || _la == SolidityParserHexNumber) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(1092)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 121, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1091)
			p.Match(SolidityParserNumberUnit)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierContext is an interface to support dynamic dispatch.
type IIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ReceiveKeyword() antlr.TerminalNode
	ConstructorKeyword() antlr.TerminalNode
	PayableKeyword() antlr.TerminalNode
	LeaveKeyword() antlr.TerminalNode
	Identifier() antlr.TerminalNode

	// IsIdentifierContext differentiates from other interfaces.
	IsIdentifierContext()
}

type IdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierContext() *IdentifierContext {
	var p = new(IdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_identifier
	return p
}

func InitEmptyIdentifierContext(p *IdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_identifier
}

func (*IdentifierContext) IsIdentifierContext() {}

func NewIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierContext {
	var p = new(IdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_identifier

	return p
}

func (s *IdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierContext) ReceiveKeyword() antlr.TerminalNode {
	return s.GetToken(SolidityParserReceiveKeyword, 0)
}

func (s *IdentifierContext) ConstructorKeyword() antlr.TerminalNode {
	return s.GetToken(SolidityParserConstructorKeyword, 0)
}

func (s *IdentifierContext) PayableKeyword() antlr.TerminalNode {
	return s.GetToken(SolidityParserPayableKeyword, 0)
}

func (s *IdentifierContext) LeaveKeyword() antlr.TerminalNode {
	return s.GetToken(SolidityParserLeaveKeyword, 0)
}

func (s *IdentifierContext) Identifier() antlr.TerminalNode {
	return s.GetToken(SolidityParserIdentifier, 0)
}

func (s *IdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterIdentifier(s)
	}
}

func (s *IdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitIdentifier(s)
	}
}

func (p *SolidityParser) Identifier() (localctx IIdentifierContext) {
	localctx = NewIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, SolidityParserRULE_identifier)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1094)
		_la = p.GetTokenStream().LA(1)

		if !(((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&18018796589563904) != 0) || ((int64((_la-96)) & ^0x3f) == 0 && ((int64(1)<<(_la-96))&6983778305) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHexLiteralContext is an interface to support dynamic dispatch.
type IHexLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllHexLiteralFragment() []antlr.TerminalNode
	HexLiteralFragment(i int) antlr.TerminalNode

	// IsHexLiteralContext differentiates from other interfaces.
	IsHexLiteralContext()
}

type HexLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHexLiteralContext() *HexLiteralContext {
	var p = new(HexLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_hexLiteral
	return p
}

func InitEmptyHexLiteralContext(p *HexLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_hexLiteral
}

func (*HexLiteralContext) IsHexLiteralContext() {}

func NewHexLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HexLiteralContext {
	var p = new(HexLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_hexLiteral

	return p
}

func (s *HexLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *HexLiteralContext) AllHexLiteralFragment() []antlr.TerminalNode {
	return s.GetTokens(SolidityParserHexLiteralFragment)
}

func (s *HexLiteralContext) HexLiteralFragment(i int) antlr.TerminalNode {
	return s.GetToken(SolidityParserHexLiteralFragment, i)
}

func (s *HexLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HexLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HexLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterHexLiteral(s)
	}
}

func (s *HexLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitHexLiteral(s)
	}
}

func (p *SolidityParser) HexLiteral() (localctx IHexLiteralContext) {
	localctx = NewHexLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, SolidityParserRULE_hexLiteral)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1097)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(1096)
				p.Match(SolidityParserHexLiteralFragment)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(1099)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 122, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOverrideSpecifierContext is an interface to support dynamic dispatch.
type IOverrideSpecifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllUserDefinedTypeName() []IUserDefinedTypeNameContext
	UserDefinedTypeName(i int) IUserDefinedTypeNameContext

	// IsOverrideSpecifierContext differentiates from other interfaces.
	IsOverrideSpecifierContext()
}

type OverrideSpecifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOverrideSpecifierContext() *OverrideSpecifierContext {
	var p = new(OverrideSpecifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_overrideSpecifier
	return p
}

func InitEmptyOverrideSpecifierContext(p *OverrideSpecifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_overrideSpecifier
}

func (*OverrideSpecifierContext) IsOverrideSpecifierContext() {}

func NewOverrideSpecifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OverrideSpecifierContext {
	var p = new(OverrideSpecifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_overrideSpecifier

	return p
}

func (s *OverrideSpecifierContext) GetParser() antlr.Parser { return s.parser }

func (s *OverrideSpecifierContext) AllUserDefinedTypeName() []IUserDefinedTypeNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUserDefinedTypeNameContext); ok {
			len++
		}
	}

	tst := make([]IUserDefinedTypeNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUserDefinedTypeNameContext); ok {
			tst[i] = t.(IUserDefinedTypeNameContext)
			i++
		}
	}

	return tst
}

func (s *OverrideSpecifierContext) UserDefinedTypeName(i int) IUserDefinedTypeNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserDefinedTypeNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserDefinedTypeNameContext)
}

func (s *OverrideSpecifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OverrideSpecifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OverrideSpecifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterOverrideSpecifier(s)
	}
}

func (s *OverrideSpecifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitOverrideSpecifier(s)
	}
}

func (p *SolidityParser) OverrideSpecifier() (localctx IOverrideSpecifierContext) {
	localctx = NewOverrideSpecifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, SolidityParserRULE_overrideSpecifier)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1101)
		p.Match(SolidityParserT__96)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1113)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SolidityParserT__22 {
		{
			p.SetState(1102)
			p.Match(SolidityParserT__22)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1103)
			p.UserDefinedTypeName()
		}
		p.SetState(1108)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == SolidityParserT__15 {
			{
				p.SetState(1104)
				p.Match(SolidityParserT__15)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1105)
				p.UserDefinedTypeName()
			}

			p.SetState(1110)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1111)
			p.Match(SolidityParserT__23)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStringLiteralContext is an interface to support dynamic dispatch.
type IStringLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllStringLiteralFragment() []antlr.TerminalNode
	StringLiteralFragment(i int) antlr.TerminalNode

	// IsStringLiteralContext differentiates from other interfaces.
	IsStringLiteralContext()
}

type StringLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringLiteralContext() *StringLiteralContext {
	var p = new(StringLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_stringLiteral
	return p
}

func InitEmptyStringLiteralContext(p *StringLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_stringLiteral
}

func (*StringLiteralContext) IsStringLiteralContext() {}

func NewStringLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringLiteralContext {
	var p = new(StringLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_stringLiteral

	return p
}

func (s *StringLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *StringLiteralContext) AllStringLiteralFragment() []antlr.TerminalNode {
	return s.GetTokens(SolidityParserStringLiteralFragment)
}

func (s *StringLiteralContext) StringLiteralFragment(i int) antlr.TerminalNode {
	return s.GetToken(SolidityParserStringLiteralFragment, i)
}

func (s *StringLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterStringLiteral(s)
	}
}

func (s *StringLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitStringLiteral(s)
	}
}

func (p *SolidityParser) StringLiteral() (localctx IStringLiteralContext) {
	localctx = NewStringLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, SolidityParserRULE_stringLiteral)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1116)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(1115)
				p.Match(SolidityParserStringLiteralFragment)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(1118)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 125, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

func (p *SolidityParser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 34:
		var t *TypeNameContext = nil
		if localctx != nil {
			t = localctx.(*TypeNameContext)
		}
		return p.TypeName_Sempred(t, predIndex)

	case 63:
		var t *ExpressionContext = nil
		if localctx != nil {
			t = localctx.(*ExpressionContext)
		}
		return p.Expression_Sempred(t, predIndex)

	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *SolidityParser) TypeName_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 0:
		return p.Precpred(p.GetParserRuleContext(), 3)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *SolidityParser) Expression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 1:
		return p.Precpred(p.GetParserRuleContext(), 14)

	case 2:
		return p.Precpred(p.GetParserRuleContext(), 13)

	case 3:
		return p.Precpred(p.GetParserRuleContext(), 12)

	case 4:
		return p.Precpred(p.GetParserRuleContext(), 11)

	case 5:
		return p.Precpred(p.GetParserRuleContext(), 10)

	case 6:
		return p.Precpred(p.GetParserRuleContext(), 9)

	case 7:
		return p.Precpred(p.GetParserRuleContext(), 8)

	case 8:
		return p.Precpred(p.GetParserRuleContext(), 7)

	case 9:
		return p.Precpred(p.GetParserRuleContext(), 6)

	case 10:
		return p.Precpred(p.GetParserRuleContext(), 5)

	case 11:
		return p.Precpred(p.GetParserRuleContext(), 4)

	case 12:
		return p.Precpred(p.GetParserRuleContext(), 3)

	case 13:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 14:
		return p.Precpred(p.GetParserRuleContext(), 27)

	case 15:
		return p.Precpred(p.GetParserRuleContext(), 25)

	case 16:
		return p.Precpred(p.GetParserRuleContext(), 24)

	case 17:
		return p.Precpred(p.GetParserRuleContext(), 23)

	case 18:
		return p.Precpred(p.GetParserRuleContext(), 22)

	case 19:
		return p.Precpred(p.GetParserRuleContext(), 21)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}
